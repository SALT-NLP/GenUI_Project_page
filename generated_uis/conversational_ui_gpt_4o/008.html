<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React Hooks Explained</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // Apply syntax highlighting to code blocks
      document.querySelectorAll('pre code').forEach((el) => {
        hljs.highlightElement(el);
      });
    });
  </script>
</head>

<body>
  <div class="container">
    <header>
      <h1>React Hooks Explained</h1>
      <button class="back-button" style="display: none;" onclick="history.back()">Go Back</button>
    </header>

    <div class="conversation-container">

      <div class="message user">
        <div class="message-header">
          <div class="message-avatar avatar-user">
            U
          </div>
          <div class="message-author">You</div>
          <div class="message-time">5/2/2025, 11:23:22 PM</div>
        </div>
        <div class="message-content">
          <p>Help me understand React hooks.</p>
        </div>
      </div>

      <div class="message assistant">
        <div class="message-header">
          <div class="message-avatar avatar-assistant">
            A
          </div>
          <div class="message-author">Assistant</div>
          <div class="message-time">5/2/2025, 11:23:22 PM</div>
        </div>
        <div class="message-content">
          <p>Sure! React <strong>hooks</strong> are special functions that let you ‚Äúhook into‚Äù React features (like
            state or lifecycle methods) in <strong>function components</strong>, which previously were only available in
            <strong>class components</strong>.</p>
          <p>Here&#39;s a breakdown of the <strong>most common hooks</strong> and how they work:</p>
          <hr>
          <h3>üß† 1. <code>useState</code>: Add state to a functional component</h3>
          <pre><code class="language-jsx">import { useState } from &#39;react&#39;;

function Counter() {
  const [count, setCount] = useState(0); // [stateValue, setterFunction]

  return (
    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
      You clicked {count} times
    &lt;/button&gt;
  );
}
</code></pre>
          <ul>
            <li><code>useState</code> returns an array with the current state and a function to update it.</li>
            <li>React re-renders the component when you update the state.</li>
          </ul>
          <hr>
          <h3>‚è± 2. <code>useEffect</code>: Side effects (e.g. fetching data, subscriptions)</h3>
          <pre><code class="language-jsx">import { useEffect } from &#39;react&#39;;

function Timer() {
  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; console.log(&#39;tick&#39;), 1000);

    return () =&gt; clearInterval(timer); // Cleanup
  }, []); // Run only once after initial render
}
</code></pre>
          <ul>
            <li>Think of it like <code>componentDidMount</code>, <code>componentDidUpdate</code>, and
              <code>componentWillUnmount</code> combined.</li>
            <li>The second argument is a <strong>dependency array</strong>: <code>[]</code> means run once,
              <code>[value]</code> means run when <code>value</code> changes.</li>
          </ul>
          <hr>
          <h3>üîÅ 3. <code>useContext</code>: Access context without <code>&lt;Context.Consumer&gt;</code></h3>
          <pre><code class="language-jsx">const ThemeContext = React.createContext(&#39;light&#39;);

function ThemedComponent() {
  const theme = useContext(ThemeContext); // Returns &#39;light&#39; or whatever is provided

  return &lt;div className={theme}&gt;Hello!&lt;/div&gt;;
}
</code></pre>
          <hr>
          <h3>üßÆ 4. <code>useMemo</code> &amp; <code>useCallback</code>: Optimization</h3>
          <pre><code class="language-jsx">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);
const memoizedCallback = useCallback(() =&gt; handleClick(id), [id]);
</code></pre>
          <ul>
            <li><code>useMemo</code> memoizes the result of a computation.</li>
            <li><code>useCallback</code> memoizes the function itself.</li>
          </ul>
          <hr>
          <h3>üîÑ 5. <code>useRef</code>: Persistent value between renders</h3>
          <pre><code class="language-jsx">const inputRef = useRef(null);

function focusInput() {
  inputRef.current.focus();
}
</code></pre>
          <ul>
            <li><code>useRef</code> gives you a mutable object whose <code>.current</code> property doesn&#39;t cause
              re-renders when updated.</li>
          </ul>
          <hr>
          <p>Would you like a diagram or real-world example showing how multiple hooks work together?</p>
        </div>
      </div>

    </div>
  </div>
</body>

</html>