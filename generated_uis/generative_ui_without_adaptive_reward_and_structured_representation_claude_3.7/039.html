<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survey Data Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        :root {
            --primary-color: #007bff;
            --primary-color-dark: #0056b3;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --white-color: #ffffff;
            --border-color: #dee2e6;
            --background-color: #f4f7f6; /* Light background */
            --card-background: var(--white-color);
            --text-color: var(--dark-color);
            --heading-color: #212529;
            --spacing-unit: 8px;
            --border-radius: 8px;
            --transition-speed: 0.3s;
            --sidebar-width: 250px;
            --header-height: 60px;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            margin: 0;
            padding: 0;
            display: flex;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
            position: relative; /* Needed for sidebar toggle positioning */
        }

        .app-header {
            background-color: var(--primary-color);
            color: var(--white-color);
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            display: flex;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: fixed;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 1000;
            height: var(--header-height); /* Fixed height */
            transition: left var(--transition-speed) ease-in-out;
        }

        .app-header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .sidebar-toggle {
             display: none; /* Hidden by default on desktop */
             background: none;
             border: none;
             color: var(--white-color);
             font-size: 2rem;
             margin-right: var(--spacing-unit);
             cursor: pointer;
             padding: 0;
             line-height: 1;
             transition: opacity var(--transition-speed) ease;
        }

        .sidebar-toggle:hover {
             opacity: 0.8;
        }


        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--dark-color);
            color: var(--light-color);
            padding-top: calc(var(--header-height) + var(--spacing-unit) * 2); /* Space for header */
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            overflow-y: auto;
            transition: transform var(--transition-speed) ease-in-out;
            z-index: 999;
            transform: translateX(0); /* Default open on desktop */
        }

        .sidebar nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar nav ul li a {
            display: flex; /* Use flex to align icon and text */
            align-items: center;
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            color: var(--light-color);
            text-decoration: none;
            transition: background-color var(--transition-speed) ease;
            font-size: 1rem;
        }

        .sidebar nav ul li a .material-symbols-rounded {
             margin-right: var(--spacing-unit);
             font-size: 1.2rem; /* Adjust icon size */
        }

        .sidebar nav ul li a:hover,
        .sidebar nav ul li a.active {
            background-color: #495057;
        }

        .main-content {
            margin-left: var(--sidebar-width); /* Space for sidebar */
            padding: calc(var(--header-height) + var(--spacing-unit) * 3) calc(var(--spacing-unit) * 3) var(--spacing-unit) calc(var(--spacing-unit) * 3); /* Space for header and padding */
            flex-grow: 1;
            transition: margin-left var(--transition-speed) ease-in-out;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
             .sidebar {
                 transform: translateX(-100%);
             }
             .sidebar.open {
                 transform: translateX(0);
             }
             .main-content {
                 margin-left: 0;
             }
             .app-header {
                 padding-left: var(--spacing-unit); /* Less padding when toggle is visible */
             }
             .sidebar-toggle {
                 display: flex; /* Show toggle on small screens */
                 align-items: center;
             }
        }


        .card {
            background-color: var(--card-background);
            border-radius: var(--border-radius);
            padding: calc(var(--spacing-unit) * 3);
            margin-bottom: calc(var(--spacing-unit) * 3);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }

        .card:hover {
             transform: translateY(-2px);
             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
        }

        .card-title {
            font-size: 1.4rem; /* Slightly larger title */
            font-weight: 700; /* Bolder */
            color: var(--heading-color);
            margin-top: 0;
            margin-bottom: calc(var(--spacing-unit) * 2);
            padding-bottom: var(--spacing-unit);
            border-bottom: 1px solid var(--border-color);
        }

        /* --- Upload Section --- */
        .upload-section {
            text-align: center;
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            padding: calc(var(--spacing-unit) * 5);
            margin-bottom: calc(var(--spacing-unit) * 3);
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
            cursor: pointer;
        }

        .upload-section.dragover {
            border-color: var(--primary-color);
            background-color: #e9f5ff; /* Light blue background */
        }

        .upload-section input[type="file"] {
            display: none;
        }

        .upload-section p {
            margin: var(--spacing-unit) 0;
            font-size: 1.1rem;
            color: var(--secondary-color);
        }

        .upload-section .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: var(--spacing-unit);
        }

        .button {
            display: inline-block;
            background-color: var(--primary-color);
            color: var(--white-color);
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            transition: background-color var(--transition-speed) ease, opacity var(--transition-speed) ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 100px; /* Ensure minimum width */
            text-align: center;
        }

        .button:hover {
            background-color: var(--primary-color-dark);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }
         .button:active {
             transform: scale(0.98);
             box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
         }

        .button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        .error-message {
             color: var(--danger-color);
             font-size: 0.9em;
             margin-top: var(--spacing-unit);
             min-height: 1.2em; /* Reserve space */
        }
         .success-message {
             color: var(--success-color);
             font-size: 0.9em;
             margin-top: var(--spacing-unit);
             min-height: 1.2em; /* Reserve space */
         }


        /* --- Data Table Section --- */
        .data-table-section {
            /* display handled by JS based on state */
        }

        .table-container {
            overflow-x: auto;
            margin-bottom: calc(var(--spacing-unit) * 2);
            max-height: 500px; /* Limit table height for scrolling */
            overflow-y: auto;
            border: 1px solid var(--border-color); /* Add border around container */
            border-radius: var(--border-radius);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 0; /* Remove margin, container has it */
            min-width: 600px; /* Ensure table is wide enough on desktop */
        }

        .data-table th,
        .data-table td {
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
            border: 1px solid var(--border-color);
            text-align: left;
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis for overflow */
            max-width: 200px; /* Limit column width */
            position: relative; /* Needed for tooltips */
        }

         .data-table td:hover::after {
            content: attr(title); /* Show full content on hover */
            position: absolute;
            left: 0;
            top: 100%; /* Position below the cell */
            z-index: 10; /* Ensure tooltip is above other content */
            background-color: var(--dark-color);
            color: var(--white-color);
            padding: var(--spacing-unit);
            border-radius: var(--border-radius);
            white-space: normal; /* Allow wrapping in tooltip */
            max-width: 300px; /* Max width for tooltip */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: block; /* Show tooltip */
         }

        .data-table th {
            background-color: var(--light-color);
            font-weight: 600;
            cursor: pointer;
            position: sticky; /* Make header sticky */
            top: 0;
            z-index: 2; /* Ensure header is above tbody */
        }

        .data-table th:hover {
            background-color: #e9ecef;
        }

        .data-table th .sort-icon {
            margin-left: var(--spacing-unit);
            font-size: 0.8em;
            vertical-align: middle;
            transition: transform var(--transition-speed) ease, opacity var(--transition-speed) ease;
            opacity: 0.5; /* Subtle default */
        }
         .data-table th:hover .sort-icon,
         .data-table th[aria-sort="ascending"] .sort-icon,
         .data-table th[aria-sort="descending"] .sort-icon {
             opacity: 1; /* Show fully when sorted or hovered */
         }


         .data-table th input[type="text"] {
            width: calc(100% - var(--spacing-unit) * 2);
            padding: var(--spacing-unit);
            margin-top: var(--spacing-unit);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.9em;
            box-sizing: border-box; /* Include padding in width */
             transition: border-color var(--transition-speed) ease;
        }
         .data-table th input[type="text"]:focus {
             outline: none;
             border-color: var(--primary-color);
             box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
         }


        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--spacing-unit);
        }

        .pagination button {
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
            background-color: var(--light-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color var(--transition-speed) ease;
        }

        .pagination button:hover:not(:disabled) {
            background-color: #e9ecef;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- Analysis Controls --- */
        .analysis-controls {
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: var(--spacing-unit) 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: var(--spacing-unit);
            transition: border-color var(--transition-speed) ease;
        }

        .controls-header:hover {
            border-color: var(--primary-color);
        }

        .controls-header h3 {
            margin: 0;
            font-size: 1.2rem; /* Slightly larger */
            font-weight: 700; /* Bolder */
        }

        .controls-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Wider minmax */
            gap: calc(var(--spacing-unit) * 3); /* Increased gap */
            padding-top: var(--spacing-unit);
            overflow: hidden;
            max-height: 0;
            transition: max-height var(--transition-speed) ease-in-out, padding-top var(--transition-speed) ease-in-out;
        }

        .controls-content.expanded {
            max-height: 1500px; /* Increased max height */
            padding-top: calc(var(--spacing-unit) * 2);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: 600;
            margin-bottom: var(--spacing-unit);
            font-size: 0.9rem;
            color: var(--heading-color);
        }

        .control-group select,
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group input[type="range"] {
            padding: var(--spacing-unit);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 1rem;
            box-sizing: border-box; /* Include padding in width */
             transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
         .control-group select:focus,
         .control-group input[type="text"]:focus,
         .control-group input[type="number"]:focus,
         .control-group input[type="range"]:focus {
             outline: none;
             border-color: var(--primary-color);
             box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
         }


        .control-group input[type="range"] {
             padding: 0; /* Range input doesn't need padding */
             height: 38px; /* Match height of other inputs */
             display: flex;
             align-items: center;
             background: transparent; /* Hide default track */
             cursor: pointer;
        }
         .control-group input[type="range"]::-webkit-slider-thumb {
             -webkit-appearance: none;
             appearance: none;
             width: 18px; /* Slightly larger thumb */
             height: 18px;
             background: var(--primary-color);
             cursor: pointer;
             border-radius: 50%;
             box-shadow: 0 1px 3px rgba(0,0,0,0.2);
             margin-top: -6px; /* Center thumb vertically */
             transition: background-color 0.1s ease, box-shadow 0.1s ease;
         }
         .control-group input[type="range"]::-moz-range-thumb {
             width: 18px;
             height: 18px;
             background: var(--primary-color);
             cursor: pointer;
             border-radius: 50%;
             box-shadow: 0 1px 3px rgba(0,0,0,0.2);
             transition: background-color 0.1s ease, box-shadow 0.1s ease;
         }
          .control-group input[type="range"]::-webkit-slider-thumb:hover {
              background: var(--primary-color-dark);
          }
          .control-group input[type="range"]::-moz-range-thumb:hover {
              background: var(--primary-color-dark);
          }

         .control-group input[type="range"]::-webkit-slider-runnable-track {
             width: 100%;
             height: 6px; /* Thicker track */
             cursor: pointer;
             background: var(--border-color);
             border-radius: 3px;
         }
         .control-group input[type="range"]::-moz-range-track {
             width: 100%;
             height: 6px;
             cursor: pointer;
             background: var(--border-color);
             border-radius: 3px;
         }

         .control-group .range-value {
             margin-top: var(--spacing-unit);
             font-size: 0.9em;
             color: var(--secondary-color);
             text-align: right;
         }

         .control-group .multi-select-dropdown {
            position: relative;
            width: 100%;
         }

         .control-group .multi-select-button {
            width: 100%;
            padding: var(--spacing-unit);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--white-color);
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
         }
          .control-group .multi-select-button:focus {
             outline: none;
             border-color: var(--primary-color);
             box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
          }

         .control-group .multi-select-options {
            position: absolute;
            top: calc(100% + 4px); /* Slightly below button */
            left: 0;
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--white-color);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 10;
            max-height: 200px;
            overflow-y: auto;
            display: none; /* Hidden by default */
         }

         .control-group .multi-select-options.show {
            display: block;
         }

         .control-group .multi-select-options label {
            display: flex;
            align-items: center;
            padding: var(--spacing-unit);
            margin-bottom: 0;
            cursor: pointer;
            font-weight: normal;
            font-size: 0.9rem;
            color: var(--text-color); /* Use text color */
         }

          .control-group .multi-select-options label:hover {
             background-color: var(--light-color);
          }

         .control-group .multi-select-options input[type="checkbox"] {
            margin-right: var(--spacing-unit);
         }


        /* --- Summary Statistics --- */
        .summary-statistics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Wider minmax */
            gap: calc(var(--spacing-unit) * 2);
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        .summary-card {
            background-color: var(--light-color);
            border-left: 4px solid var(--primary-color);
            border-radius: var(--border-radius);
            padding: calc(var(--spacing-unit) * 2);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .summary-card h4 {
            margin-top: 0;
            margin-bottom: var(--spacing-unit);
            font-size: 1rem;
            color: var(--secondary-color);
        }

        .summary-card p {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--heading-color);
            word-break: break-word; /* Break long words in stats */
        }


        /* --- Visualization Area --- */
        .visualization-area {
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        .chart-controls-bar { /* Renamed to avoid conflict with floating controls */
            display: flex;
            gap: calc(var(--spacing-unit) * 2);
            margin-bottom: calc(var(--spacing-unit) * 2);
            align-items: center;
            flex-wrap: wrap; /* Allow controls to wrap on smaller screens */
        }

        .chart-controls-bar label {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .chart-controls-bar select {
            padding: var(--spacing-unit);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 1rem;
             transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
         .chart-controls-bar select:focus {
             outline: none;
             border-color: var(--primary-color);
             box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
         }


        .chart-container {
            position: relative;
            height: 400px; /* Fixed height for chart */
            background-color: var(--white-color);
            border-radius: var(--border-radius);
            padding: calc(var(--spacing-unit) * 2);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            cursor: pointer; /* Indicate interactivity */
        }

        /* Floating controls for chart */
        .chart-container .floating-controls {
            position: absolute;
            top: var(--spacing-unit);
            right: var(--spacing-unit);
            background: rgba(255, 255, 255, 0.95);
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(-10px);
            transition: all var(--transition-speed) ease;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-unit);
        }
         .chart-container .floating-controls.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .chart-container .floating-controls .control-group {
             margin: 0;
             display: flex;
             flex-direction: row;
             align-items: center;
             gap: var(--spacing-unit);
        }

        .chart-container .floating-controls .control-group label {
            font-size: 0.9em;
            font-weight: normal;
            margin-bottom: 0;
            white-space: nowrap;
            color: var(--text-color);
        }
         .chart-container .floating-controls .control-group input[type="color"],
         .chart-container .floating-controls .control-group select,
         .chart-container .floating-controls .control-group input[type="number"] {
            padding: var(--spacing-unit);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.9em;
            height: 30px; /* Consistent height */
            box-sizing: border-box;
             transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
         .chart-container .floating-controls .control-group input[type="color"]:focus,
         .chart-container .floating-controls .control-group select:focus,
         .chart-container .floating-controls .control-group input[type="number"]:focus {
             outline: none;
             border-color: var(--primary-color);
             box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
         }


        .chart-container canvas {
             width: 100% !important;
             height: 100% !important;
        }


        /* --- Export Button --- */
        .export-section {
            text-align: right;
        }

        /* --- Utility Classes --- */
        .hidden {
            display: none;
        }

        /* Material Icons (for upload, sort, toggle) */
        .material-symbols-rounded {
            font-variation-settings:
            'FILL' 0,
            'wght' 400,
            'GRAD' 0,
            'opsz' 24;
            vertical-align: middle;
        }
    </style>
</head>
<body>

    <header class="app-header">
        <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
             <span class="material-symbols-rounded">menu</span>
        </button>
        <h1>Survey Data Dashboard</h1>
    </header>

    <aside class="sidebar" id="sidebar">
        <nav>
            <ul>
                <li><a href="#" id="nav-upload" class="active" aria-label="Upload Data"><span class="material-symbols-rounded">upload_file</span>Upload Data</a></li>
                <li><a href="#" id="nav-analysis" class="hidden" aria-label="Analysis"><span class="material-symbols-rounded">analytics</span>Analysis</a></li>
                 <!-- Data table link points to analysis section -->
                <li><a href="#" id="nav-data" class="hidden" aria-label="View Data"><span class="material-symbols-rounded">table_chart</span>View Data</a></li>
                <li><a href="#" id="nav-reports" class="hidden" aria-label="Reports"><span class="material-symbols-rounded">report</span>Reports</a></li>
            </ul>
        </nav>
    </aside>

    <main class="main-content">

        <!-- Data Upload Section -->
        <section id="upload-section" class="card upload-section" aria-label="Data Upload Area" role="region">
            <span class="material-symbols-rounded upload-icon">upload_file</span>
            <p>Drag and drop your CSV file here, or</p>
            <input type="file" id="file-input" accept=".csv" aria-label="Upload CSV file">
            <button class="button" id="browse-button" aria-controls="file-name file-error">Browse Files</button>
            <p id="file-name" class="success-message" aria-live="polite"></p>
            <p id="file-error" class="error-message" aria-live="assertive"></p>
        </section>

        <!-- Data Analysis & Visualization Section -->
        <section id="analysis-section" class="hidden" aria-label="Data Analysis and Visualization" role="region">

            <!-- Analysis Controls Panel -->
            <div class="card analysis-controls">
                <div class="controls-header" id="controls-header" role="button" aria-expanded="false" aria-controls="controls-content" tabindex="0">
                    <h3>Analysis Controls</h3>
                    <span class="material-symbols-rounded">expand_more</span>
                </div>
                <div class="controls-content" id="controls-content">
                    <!-- Dynamic filter/group controls will be added here -->
                     <p id="controls-placeholder">Upload data to see analysis controls.</p>
                </div>
            </div>

            <!-- Summary Statistics Panel -->
            <div class="card">
                <h2 class="card-title">Summary Statistics</h2>
                <div class="summary-statistics" id="summary-statistics" aria-live="polite">
                    <!-- Summary cards will be added here -->
                    <div class="summary-card">
                        <h4>Total Responses</h4>
                        <p id="stat-total">0</p>
                    </div>
                </div>
            </div>

            <!-- Visualization Area -->
            <div class="card visualization-area">
                <h2 class="card-title">Data Visualization</h2>
                 <div class="chart-controls-bar">
                    <label for="chart-type-select">Chart Type:</label>
                    <select id="chart-type-select" aria-label="Select chart type">
                        <option value="bar">Bar Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="line">Line Chart</option>
                        <!-- Add more chart types as needed -->
                    </select>

                     <label for="chart-data-select">Visualize:</label>
                    <select id="chart-data-select" aria-label="Select data column for chart">
                        <!-- Options populated by JS (e.g., survey questions) -->
                         <option value="">Select a column</option>
                    </select>
                </div>
                <div class="chart-container" role="img" aria-label="Data visualization chart area. Click to show chart options.">
                    <canvas id="myChart"></canvas>
                     <!-- Floating control panel -->
                    <div class="floating-controls" id="chart-controls" aria-label="Chart controls">
                        <div class="control-group">
                            <label for="chart-color">Color:</label>
                            <input type="color" id="chart-color" value="#007bff" aria-label="Chart color">
                        </div>
                         <div class="control-group">
                            <label for="chart-font-size">Font Size:</label>
                            <input type="number" id="chart-font-size" value="12" min="8" max="24" aria-label="Chart font size">
                        </div>
                         <!-- Add more chart-specific controls here -->
                    </div>
                </div>
            </div>

            <!-- Data Table Component -->
             <div class="card data-table-section">
                <h2 class="card-title">Raw Data</h2>
                <div class="table-container">
                    <table class="data-table" id="data-table" aria-live="polite">
                        <thead>
                            <tr>
                                <!-- Table headers populated by JS -->
                            </tr>
                             <tr id="filter-row">
                                <!-- Filter inputs populated by JS -->
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Table rows populated by JS -->
                        </tbody>
                    </table>
                </div>
                 <div class="pagination" role="navigation" aria-label="Pagination">
                    <button id="prev-page" disabled aria-label="Previous page">Previous</button>
                    <span id="page-info" aria-live="polite">Page 1 of 1</span>
                    <button id="next-page" disabled aria-label="Next page">Next</button>
                 </div>
            </div>


            <!-- Export Button -->
            <div class="export-section">
                 <button class="button" id="export-data-button" aria-label="Export data as CSV">Export Data (CSV)</button>
                 <button class="button" id="export-chart-button" aria-label="Export chart as PNG">Export Chart (PNG)</button>
            </div>

        </section>

    </main>

    <script type="module">
        import { Chart } from "https://esm.sh/chart.js/auto";
        import { parse } from "https://esm.sh/papaparse"; // Using papaparse for CSV parsing

        let rawData = []; // Original data from CSV
        let filteredData = []; // Data after applying analysis panel filters
        let tableFilteredData = []; // Data after applying table header filters (subset of filteredData)
        let currentChart = null; // Chart.js instance
        let currentPage = 1;
        const rowsPerPage = 20;
        let sortColumn = null;
        let sortDirection = 'asc'; // 'asc' or 'desc'
        let analysisFilters = {}; // { columnName: filterValue } - from analysis panel
        let tableHeaderFilters = {}; // { columnName: filterValue } - from table headers
        let filterTimeout; // To debounce filter input


        // --- DOM Elements ---
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const uploadSection = document.getElementById('upload-section');
        const fileInput = document.getElementById('file-input');
        const browseButton = document.getElementById('browse-button');
        const fileNameDisplay = document.getElementById('file-name');
        const fileErrorDisplay = document.getElementById('file-error');
        const analysisSection = document.getElementById('analysis-section');
        const dataTableSection = analysisSection.querySelector('.data-table-section');
        const dataTable = document.getElementById('data-table');
        const tableBody = dataTable.querySelector('tbody');
        const tableHeaderRow = dataTable.querySelector('thead tr:first-child');
        const tableFilterRow = document.getElementById('filter-row');
        const prevPageButton = document.getElementById('prev-page');
        const nextPageButton = document.getElementById('next-page');
        const pageInfoSpan = document.getElementById('page-info');
        const summaryStatisticsDiv = document.getElementById('summary-statistics');
        const controlsHeader = document.getElementById('controls-header');
        const controlsContent = document.getElementById('controls-content');
        const controlsPlaceholder = document.getElementById('controls-placeholder');
        const chartTypeSelect = document.getElementById('chart-type-select');
        const chartDataSelect = document.getElementById('chart-data-select');
        const chartCanvas = document.getElementById('myChart');
        const chartControls = document.getElementById('chart-controls');
        const chartColorInput = document.getElementById('chart-color');
        const chartFontSizeInput = document.getElementById('chart-font-size');
        const exportDataButton = document.getElementById('export-data-button');
        const exportChartButton = document.getElementById('export-chart-button');
        const navUpload = document.getElementById('nav-upload');
        const navData = document.getElementById('nav-data');
        const navAnalysis = document.getElementById('nav-analysis');
        const navReports = document.getElementById('nav-reports'); // Placeholder


        // --- Event Listeners ---

        // Sidebar Toggle
        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
        });

        // File Upload
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        browseButton.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        // Navigation
        navUpload.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('upload');
            // Close sidebar on mobile after navigation
            if (window.innerWidth <= 768) {
                 sidebar.classList.remove('open');
            }
        });
         navData.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('analysis'); // Data table is part of analysis section for now
             // Close sidebar on mobile after navigation
             if (window.innerWidth <= 768) {
                 sidebar.classList.remove('open');
            }
        });
         navAnalysis.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('analysis');
             // Close sidebar on mobile after navigation
             if (window.innerWidth <= 768) {
                 sidebar.classList.remove('open');
            }
        });
         navReports.addEventListener('click', (e) => {
            e.preventDefault();
            // showSection('reports'); // Placeholder
             // Close sidebar on mobile after navigation
             if (window.innerWidth <= 768) {
                 sidebar.classList.remove('open');
            }
         });


        // Analysis Controls Toggle
        controlsHeader.addEventListener('click', () => {
            controlsContent.classList.toggle('expanded');
             const isExpanded = controlsContent.classList.contains('expanded');
             controlsHeader.setAttribute('aria-expanded', isExpanded);
             const icon = controlsHeader.querySelector('.material-symbols-rounded');
             icon.textContent = isExpanded ? 'expand_less' : 'expand_more';
        });
         // Allow keyboard toggle for analysis controls
         controlsHeader.addEventListener('keydown', (e) => {
             if (e.key === 'Enter' || e.key === ' ') {
                 e.preventDefault();
                 controlsHeader.click();
             }
         });


        // Pagination
        prevPageButton.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                renderTable();
            }
        });

        nextPageButton.addEventListener('click', () => {
            const totalPages = Math.ceil(tableFilteredData.length / rowsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                renderTable();
            }
        });

        // Chart Type/Data Change
        chartTypeSelect.addEventListener('change', renderChart);
        chartDataSelect.addEventListener('change', renderChart);
         chartColorInput.addEventListener('input', updateChartControls); // Use input for real-time update
         chartFontSizeInput.addEventListener('input', updateChartControls);

        // Chart Floating Controls Toggle
        const chartContainer = document.querySelector('.chart-container');
        chartContainer.addEventListener('click', (e) => {
             // Toggle controls only if the click wasn't inside the controls panel itself
             if (!e.target.closest('.floating-controls')) {
                chartControls.classList.toggle('active');
                e.stopPropagation(); // Prevent click from propagating further
             }
        });


        // Close floating controls when clicking outside
        document.addEventListener('click', (e) => {
            // Check if the click is outside the chart container AND the floating controls
            if (!e.target.closest('.chart-container') && chartControls.classList.contains('active')) {
                chartControls.classList.remove('active');
            }
        });


        // Export Buttons
        exportDataButton.addEventListener('click', exportCSV);
        exportChartButton.addEventListener('click', exportChartPNG);


        // --- Data Handling Functions ---

        function handleFile(file) {
            if (file.type !== 'text/csv') {
                fileErrorDisplay.textContent = 'Please upload a CSV file.';
                fileNameDisplay.textContent = '';
                rawData = [];
                filteredData = [];
                tableFilteredData = [];
                showSection('upload');
                return;
            }

            fileNameDisplay.textContent = `Loading: ${file.name}`;
            fileErrorDisplay.textContent = '';
            fileErrorDisplay.style.color = 'var(--danger-color)'; // Reset color in case of previous error
            fileNameDisplay.style.color = 'var(--heading-color)'; // Reset color

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                parse(text, {
                    header: true,
                    dynamicTyping: true, // Attempt to convert strings to numbers/booleans
                    skipEmptyLines: true,
                    complete: (results) => {
                        if (results.errors.length > 0) {
                             console.error("Parsing errors:", results.errors);
                            fileErrorDisplay.textContent = `Error parsing CSV: ${results.errors[0].message}`;
                            fileNameDisplay.textContent = '';
                            rawData = [];
                            filteredData = [];
                            tableFilteredData = [];
                            showSection('upload');
                        } else if (!results.data || results.data.length === 0) {
                            fileErrorDisplay.textContent = 'CSV file is empty or has no valid data.';
                            fileNameDisplay.textContent = '';
                            rawData = [];
                            filteredData = [];
                            tableFilteredData = [];
                            showSection('upload');
                        }
                        else {
                            // Clean data: remove rows that are just empty objects (can happen with skipEmptyLines)
                            rawData = results.data.filter(row => Object.values(row).some(val => val !== null && val !== undefined && val !== ''));
                             if (rawData.length === 0) {
                                fileErrorDisplay.textContent = 'CSV file contains no valid data rows after cleaning.';
                                fileNameDisplay.textContent = '';
                                rawData = [];
                                filteredData = [];
                                tableFilteredData = [];
                                showSection('upload');
                                return;
                             }

                            filteredData = [...rawData]; // Start with all data for analysis filters
                            tableFilteredData = [...filteredData]; // Start with filteredData for table filters
                            fileNameDisplay.textContent = `Loaded: ${file.name} (${rawData.length} rows)`;
                             fileErrorDisplay.textContent = ''; // Clear any previous error message
                            initializeDashboard();
                            showSection('analysis');
                        }
                    }
                });
            };
            reader.onerror = () => {
                fileErrorDisplay.textContent = 'Failed to read file.';
                 fileNameDisplay.textContent = '';
                 rawData = [];
                 filteredData = [];
                 tableFilteredData = [];
                 showSection('upload');
            };
            reader.readAsText(file);
        }

        function initializeDashboard() {
            if (rawData.length === 0) return;

            // Infer column types (simple heuristic)
            const columnTypes = inferColumnTypes(rawData);
            console.log("Inferred column types:", columnTypes);

            // Populate analysis controls
            populateAnalysisControls(columnTypes);

            // Populate chart data select
            populateChartDataSelect(columnTypes);

            // Calculate and display summary statistics
            calculateSummaryStatistics();

            // Reset filters and sorting
            analysisFilters = {};
            tableHeaderFilters = {};
            sortColumn = null;
            sortDirection = 'asc';

            // Apply initial filters (which are none) and render table
            applyFilters(); // This will update filteredData and call renderTable

            // Render the initial chart
            renderChart();

            // Show relevant navigation links
            navData.classList.remove('hidden');
            navAnalysis.classList.remove('hidden');
            // navReports.classList.remove('hidden'); // Keep reports hidden for now if not implemented
        }

        function inferColumnTypes(data) {
             if (data.length === 0) return {};

             const types = {};
             const headers = Object.keys(data[0]);

             headers.forEach(header => {
                 const values = data.map(row => row[header]).filter(val => val !== null && val !== undefined && val !== '');
                 if (values.length === 0) {
                     types[header] = 'empty';
                     return;
                 }

                 // Check for numerical
                 const numericalValues = values.filter(val => typeof val === 'number' || (typeof val === 'string' && !isNaN(parseFloat(val)) && val.trim() !== ''));
                 if (numericalValues.length > 0 && numericalValues.length / values.length > 0.8) { // If > 80% are numerical AND there's at least one
                     types[header] = 'numerical';
                     return;
                 }

                 // Check for boolean (case-insensitive true/false, 0/1)
                 const booleanValues = values.filter(val =>
                     typeof val === 'boolean' ||
                     (typeof val === 'string' && (val.toLowerCase() === 'true' || val.toLowerCase() === 'false')) ||
                     val === 0 || val === 1
                 );
                 if (booleanValues.length > 0 && booleanValues.length / values.length > 0.8) { // If > 80% are boolean-like AND there's at least one
                      types[header] = 'boolean';
                      return;
                 }

                 // Check for categorical (if number of unique values is small relative to total rows)
                 const uniqueValues = new Set(values.map(String)).size;
                 if (uniqueValues / values.length < 0.2 && uniqueValues < 50) { // If < 20% unique AND < 50 unique values
                     types[header] = 'categorical';
                     return;
                 }

                 // Default to text
                 types[header] = 'text';
             });

             return types;
        }


        function populateAnalysisControls(columnTypes) {
             controlsContent.innerHTML = ''; // Clear existing controls
             controlsPlaceholder.classList.add('hidden'); // Hide placeholder

             if (rawData.length === 0) {
                 controlsPlaceholder.classList.remove('hidden');
                 return;
             }

             const headers = Object.keys(rawData[0]);

             headers.forEach(header => {
                 const controlGroup = document.createElement('div');
                 controlGroup.classList.add('control-group');

                 const label = document.createElement('label');
                 label.textContent = `${header}:`;
                 label.setAttribute('for', `filter-${header}`);

                 controlGroup.appendChild(label);

                 const type = columnTypes[header] || 'text';

                 if (type === 'categorical' || type === 'boolean') {
                     // Use multi-select dropdown for categorical/boolean
                     const uniqueValues = [...new Set(rawData.map(row => String(row[header])).filter(val => val !== null && val !== undefined && val !== ''))].sort();

                     const dropdown = document.createElement('div');
                     dropdown.classList.add('multi-select-dropdown');

                     const button = document.createElement('button');
                     button.type = 'button';
                     button.classList.add('multi-select-button');
                     button.textContent = 'Select values...';
                     button.setAttribute('aria-haspopup', 'listbox');
                     button.setAttribute('aria-expanded', 'false');
                     button.setAttribute('id', `multi-select-button-${header.replace(/\s+/g, '-')}`); // Add ID for accessibility

                     const optionsDiv = document.createElement('div');
                     optionsDiv.classList.add('multi-select-options');
                     optionsDiv.setAttribute('role', 'listbox');
                     optionsDiv.setAttribute('aria-labelledby', `multi-select-button-${header.replace(/\s+/g, '-')}`); // Link to button


                     // Add "Select All" option
                     const selectAllLabel = document.createElement('label');
                     const selectAllCheckbox = document.createElement('input');
                     selectAllCheckbox.type = 'checkbox';
                     selectAllCheckbox.checked = true; // Default to all selected
                     selectAllCheckbox.setAttribute('aria-label', `Select all for ${header}`);
                     selectAllLabel.appendChild(selectAllCheckbox);
                     selectAllLabel.appendChild(document.createTextNode('Select All'));
                     optionsDiv.appendChild(selectAllLabel);


                     uniqueValues.forEach(value => {
                         const optionLabel = document.createElement('label');
                         const checkbox = document.createElement('input');
                         checkbox.type = 'checkbox';
                         checkbox.value = value;
                         checkbox.checked = true; // Default to all selected
                         checkbox.setAttribute('aria-label', value);

                         optionLabel.appendChild(checkbox);
                         optionLabel.appendChild(document.createTextNode(value));
                         optionsDiv.appendChild(optionLabel);

                          // Add event listener to individual checkboxes
                         checkbox.addEventListener('change', () => {
                              // If any individual checkbox is unchecked, uncheck "Select All"
                             if (!checkbox.checked) {
                                 selectAllCheckbox.checked = false;
                             } else {
                                 // If all individual checkboxes are checked, check "Select All"
                                 const allChecked = Array.from(optionsDiv.querySelectorAll('input[type="checkbox"]:not(:first-child)')).every(cb => cb.checked);
                                 selectAllCheckbox.checked = allChecked;
                             }
                             // Apply filter after any checkbox change
                             updateMultiSelectFilter(header, dropdown);
                             applyFilters(); // Apply analysis filters
                         });
                     });

                      // Add event listener to "Select All" checkbox
                     selectAllCheckbox.addEventListener('change', () => {
                         const isChecked = selectAllCheckbox.checked;
                         optionsDiv.querySelectorAll('input[type="checkbox"]:not(:first-child)').forEach(cb => {
                             cb.checked = isChecked;
                         });
                         updateMultiSelectFilter(header, dropdown);
                         applyFilters(); // Apply analysis filters
                     });


                     dropdown.appendChild(button);
                     dropdown.appendChild(optionsDiv);
                     controlGroup.appendChild(dropdown);

                     // Toggle dropdown visibility
                     button.addEventListener('click', (e) => {
                         optionsDiv.classList.toggle('show');
                         button.setAttribute('aria-expanded', optionsDiv.classList.contains('show'));
                         e.stopPropagation(); // Prevent closing immediately from document click
                     });

                     // Close dropdown when clicking outside
                     document.addEventListener('click', (e) => {
                         if (!dropdown.contains(e.target)) {
                             optionsDiv.classList.remove('show');
                             button.setAttribute('aria-expanded', 'false');
                         }
                     });

                     // Initialize filter state for multi-select (all values initially included)
                     analysisFilters[header] = uniqueValues;


                 } else if (type === 'numerical') {
                     // Use range slider for numerical
                     const values = rawData.map(row => parseFloat(row[header])).filter(val => !isNaN(val));
                     if (values.length > 0) {
                         const min = Math.min(...values);
                         const max = Math.max(...values);

                         const rangeInput = document.createElement('input');
                         rangeInput.type = 'range';
                         rangeInput.id = `filter-${header.replace(/\s+/g, '-')}`;
                         rangeInput.min = min;
                         rangeInput.max = max;
                         rangeInput.value = max; // Default to max
                         rangeInput.step = (max - min) / 1000 || 0.01; // More steps for better granularity
                         rangeInput.setAttribute('aria-label', `Filter ${header} up to value`);

                         const valueDisplay = document.createElement('div');
                         valueDisplay.classList.add('range-value');
                         valueDisplay.textContent = `Max: ${parseFloat(rangeInput.value).toFixed(2)}`; // Display initial max value

                         rangeInput.addEventListener('input', (e) => {
                             valueDisplay.textContent = `Max: ${parseFloat(e.target.value).toFixed(2)}`;
                             // Debounce filter application
                             clearTimeout(filterTimeout);
                             filterTimeout = setTimeout(() => {
                                 analysisFilters[header] = parseFloat(e.target.value);
                                 applyFilters(); // Apply analysis filters
                             }, 100); // Shorter debounce for range
                         });

                         controlGroup.appendChild(rangeInput);
                         controlGroup.appendChild(valueDisplay);

                         // Initialize filter state for range (filter up to max value)
                         analysisFilters[header] = max;

                     } else {
                         // Fallback to text input if no numerical values found
                         const input = document.createElement('input');
                         input.type = 'text';
                         input.id = `filter-${header.replace(/\s+/g, '-')}`;
                         input.placeholder = `Filter ${header}...`;
                         input.setAttribute('aria-label', `Filter by ${header}`);
                          input.addEventListener('input', (e) => {
                             // Debounce filter application
                             clearTimeout(filterTimeout);
                             filterTimeout = setTimeout(() => {
                                 analysisFilters[header] = e.target.value.toLowerCase();
                                 applyFilters(); // Apply analysis filters
                             }, 300); // 300ms debounce
                         });
                         controlGroup.appendChild(input);
                          analysisFilters[header] = ''; // Initialize filter state
                     }

                 } else { // Default to text input for text/empty types
                     const input = document.createElement('input');
                     input.type = 'text';
                     input.id = `filter-${header.replace(/\s+/g, '-')}`;
                     input.placeholder = `Filter ${header}...`;
                     input.setAttribute('aria-label', `Filter by ${header}`);
                      input.addEventListener('input', (e) => {
                         // Debounce filter application
                         clearTimeout(filterTimeout);
                         filterTimeout = setTimeout(() => {
                             analysisFilters[header] = e.target.value.toLowerCase();
                             applyFilters(); // Apply analysis filters
                         }, 300); // 300ms debounce
                     });
                     controlGroup.appendChild(input);
                      analysisFilters[header] = ''; // Initialize filter state
                 }

                 controlsContent.appendChild(controlGroup);
             });
        }

        function updateMultiSelectFilter(header, dropdownElement) {
             const checkboxes = dropdownElement.querySelectorAll('.multi-select-options input[type="checkbox"]:not(:first-child)');
             const selectedValues = Array.from(checkboxes)
                 .filter(cb => cb.checked)
                 .map(cb => cb.value);

             analysisFilters[header] = selectedValues;

             // Update button text
             const button = dropdownElement.querySelector('.multi-select-button');
             if (selectedValues.length === 0) {
                 button.textContent = 'No values selected';
             } else if (selectedValues.length === checkboxes.length) {
                 button.textContent = 'All values selected';
             } else {
                 button.textContent = `${selectedValues.length} selected`;
             }
        }


        function populateChartDataSelect(columnTypes) {
            chartDataSelect.innerHTML = '<option value="">Select a column</option>'; // Clear existing options, add default
            if (rawData.length === 0) return;

             const headers = Object.keys(rawData[0]);

             // Add headers as options, prioritizing numerical/categorical
             const prioritizedHeaders = headers.filter(h => columnTypes[h] === 'numerical' || columnTypes[h] === 'categorical' || columnTypes[h] === 'boolean');
             const otherHeaders = headers.filter(h => !prioritizedHeaders.includes(h));

             [...prioritizedHeaders, ...otherHeaders].forEach(header => {
                 const option = document.createElement('option');
                 option.value = header;
                 option.textContent = header;
                 chartDataSelect.appendChild(option);
             });

             // Select the first prioritized column, or the very first if none prioritized
             if (prioritizedHeaders.length > 0) {
                 chartDataSelect.value = prioritizedHeaders[0];
             } else if (headers.length > 0) {
                 chartDataSelect.value = headers[0];
             } else {
                 chartDataSelect.value = ""; // No columns available
             }
             // Trigger chart render if data is loaded and a column is selected
             if (filteredData.length > 0 && chartDataSelect.value) {
                 renderChart();
             } else {
                 // Clear chart if no data or no column selected
                 if (currentChart) {
                     currentChart.destroy();
                     currentChart = null;
                 }
                  chartCanvas.style.display = 'none';
                  chartControls.classList.remove('active');
             }
        }


        function applyFilters() {
             // Apply analysis panel filters to rawData
             filteredData = rawData.filter(row => {
                 for (const header in analysisFilters) {
                     const filterValue = analysisFilters[header];
                     const rowValue = row[header];
                     const columnType = inferColumnTypes([row])[header] || 'text'; // Infer type for this row's value

                     // Handle different filter types
                     if (columnType === 'categorical' || columnType === 'boolean') {
                         // Multi-select filter: check if the row value is in the list of selected values
                         const stringRowValue = String(rowValue !== undefined && rowValue !== null ? rowValue : '');
                         if (Array.isArray(filterValue) && filterValue.length > 0 && !filterValue.includes(stringRowValue)) {
                             return false;
                         }
                     } else if (columnType === 'numerical') {
                         // Range filter: check if the numerical value is within the range (less than or equal to max)
                         const numRowValue = parseFloat(rowValue);
                         if (!isNaN(numRowValue) && typeof filterValue === 'number' && numRowValue > filterValue) {
                             return false;
                         }
                     } else { // Text filter
                         // Text filter: check if the row value (as string) includes the filter string (case-insensitive)
                         const stringRowValue = String(rowValue !== undefined && rowValue !== null ? rowValue : '').toLowerCase();
                         if (typeof filterValue === 'string' && filterValue && !stringRowValue.includes(filterValue)) {
                             return false;
                         }
                     }
                 }
                 return true; // Row matches all analysis filters
             });

             // After applying analysis filters, update tableHeaderFilters based on current filteredData columns
             // This ensures table filters are only applied to columns present after analysis filtering
             const currentHeaders = filteredData.length > 0 ? Object.keys(filteredData[0]) : [];
             for (const header in tableHeaderFilters) {
                 if (!currentHeaders.includes(header)) {
                     delete tableHeaderFilters[header]; // Remove table filter if column is gone
                 }
             }
             // No need to reset tableHeaderFilters here, they persist within the analysis-filtered view

             currentPage = 1; // Reset to first page after analysis filtering
             renderTable(); // Re-render table based on new filteredData and existing tableHeaderFilters
             calculateSummaryStatistics(); // Update stats based on filtered data
             renderChart(); // Update chart based on filtered data
        }


        function applyTableHeaderFilters(dataToFilter) {
             // Applies text filters from table headers to a given dataset
             return dataToFilter.filter(row => {
                 for (const header in tableHeaderFilters) {
                     const filterValue = tableHeaderFilters[header];
                     if (filterValue) { // Only apply if filter value is not empty
                          const rowValue = row[header];
                          const stringRowValue = String(rowValue !== undefined && rowValue !== null ? rowValue : '').toLowerCase();
                          if (!stringRowValue.includes(filterValue)) {
                              return false;
                          }
                     }
                 }
                 return true; // Row matches all table header filters
             });
        }


        function calculateSummaryStatistics() {
            summaryStatisticsDiv.innerHTML = ''; // Clear existing stats
            if (filteredData.length === 0) {
                 summaryStatisticsDiv.innerHTML = '<p>No data available for statistics based on current filters.</p>';
                 return;
            }

            const headers = Object.keys(filteredData[0]);
            const columnTypes = inferColumnTypes(filteredData); // Infer types on filtered data

            // Total Responses
            addSummaryCard('Total Responses', filteredData.length);

            headers.forEach(header => {
                 const type = columnTypes[header];
                 const values = filteredData.map(row => row[header]).filter(val => val !== null && val !== undefined && val !== '');

                 if (values.length === 0) return; // Skip columns with no data in filtered set

                 if (type === 'categorical' || type === 'boolean') {
                     // Distinct values count
                     const distinctValues = new Set(values.map(String)).size;
                     addSummaryCard(`Distinct ${header}`, distinctValues);

                     // Mode (most frequent) - simple version
                     const counts = {};
                     values.map(String).forEach(val => { counts[val] = (counts[val] || 0) + 1; });
                     let mode = null;
                     let maxCount = 0;
                     let modes = []; // Handle multiple modes
                     for (const val in counts) {
                         if (counts[val] > maxCount) {
                             maxCount = counts[val];
                             modes = [val]; // Start new mode list
                         } else if (counts[val] === maxCount && maxCount > 0) {
                             modes.push(val); // Add to existing modes
                         }
                     }
                     if (modes.length > 0) {
                         addSummaryCard(`Mode ${header}`, `${modes.join(', ')} (${maxCount})`);
                     }


                 } else if (type === 'numerical') {
                     const numericalValues = values.map(parseFloat).filter(val => !isNaN(val));
                     if (numericalValues.length > 0) {
                         // Average
                         const sum = numericalValues.reduce((acc, val) => acc + val, 0);
                         const average = sum / numericalValues.length;
                         addSummaryCard(`Average ${header}`, average.toFixed(2));

                         // Min
                         const min = Math.min(...numericalValues);
                         addSummaryCard(`Min ${header}`, min.toFixed(2));

                         // Max
                         const max = Math.max(...numericalValues);
                         addSummaryCard(`Max ${header}`, max.toFixed(2));

                          // Median (simple)
                         const sortedValues = [...numericalValues].sort((a, b) => a - b);
                         const mid = Math.floor(sortedValues.length / 2);
                         const median = sortedValues.length % 2 !== 0 ? sortedValues[mid] : (sortedValues[mid - 1] + sortedValues[mid]) / 2;
                         addSummaryCard(`Median ${header}`, median.toFixed(2));
                     }
                 }
                 // Add other types of statistics as needed
            });
        }

        function addSummaryCard(title, value) {
             const card = document.createElement('div');
             card.classList.add('summary-card');
             card.innerHTML = `<h4>${title}</h4><p>${value}</p>`;
             summaryStatisticsDiv.appendChild(card);
        }


        // --- Table Rendering Functions ---

        function renderTable() {
            tableBody.innerHTML = ''; // Clear existing rows
            tableHeaderRow.innerHTML = ''; // Clear existing headers
            tableFilterRow.innerHTML = ''; // Clear existing filters

            if (filteredData.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="100%">No data available based on current filters.</td></tr>';
                pageInfoSpan.textContent = 'Page 0 of 0';
                prevPageButton.disabled = true;
                nextPageButton.disabled = true;
                 // Clear table header filters if no data
                 tableHeaderFilters = {};
                 return;
            }

            const headers = Object.keys(filteredData[0]);
            // const columnTypes = inferColumnTypes(filteredData); // Infer types for rendering hints - not strictly needed for table rendering itself

            // Render headers
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                th.setAttribute('data-column', header);
                th.setAttribute('aria-sort', sortColumn === header ? (sortDirection === 'asc' ? 'ascending' : 'descending') : 'none');
                th.addEventListener('click', handleSort);
                th.setAttribute('tabindex', '0'); // Make headers focusable for keyboard sort

                 // Add sort icon placeholder
                 const sortIcon = document.createElement('span');
                 sortIcon.classList.add('material-symbols-rounded', 'sort-icon');
                 if (sortColumn === header) {
                     sortIcon.textContent = sortDirection === 'asc' ? 'arrow_upward' : 'arrow_downward';
                 } else {
                      sortIcon.textContent = 'sort'; // Default sort icon
                 }
                 th.appendChild(sortIcon);

                tableHeaderRow.appendChild(th);

                 // Render filter input in the filter row
                 const filterTh = document.createElement('th');
                 const filterInput = document.createElement('input');
                 filterInput.type = 'text';
                 filterInput.placeholder = `Filter ${header}...`;
                 // Ensure tableHeaderFilters is initialized for this header if it doesn't exist
                 if (tableHeaderFilters[header] === undefined) {
                     tableHeaderFilters[header] = '';
                 }
                 filterInput.value = tableHeaderFilters[header]; // Restore filter value
                 filterInput.setAttribute('aria-label', `Filter table by ${header}`);
                 filterInput.setAttribute('data-column', header); // Link input to column
                 filterInput.addEventListener('input', handleTableFilterInput); // Use dedicated handler

                 filterTh.appendChild(filterInput);
                 tableFilterRow.appendChild(filterTh);
            });

            // Apply table header filters to the already analysis-filtered data
            tableFilteredData = applyTableHeaderFilters(filteredData);

            // Apply sorting to the table-filtered data
            const sortedData = [...tableFilteredData]; // Work on a copy
            if (sortColumn) {
                sortedData.sort((a, b) => {
                    const valA = a[sortColumn];
                    const valB = b[sortColumn];

                    // Handle null/undefined values
                    if (valA == null && valB == null) return 0;
                    if (valA == null) return sortDirection === 'asc' ? -1 : 1;
                    if (valB == null) return sortDirection === 'asc' ? 1 : -1;

                    // Basic comparison for numbers and strings
                    if (typeof valA === 'number' && typeof valB === 'number') {
                        return sortDirection === 'asc' ? valA - valB : valB - valA;
                    } else {
                        const stringA = String(valA).toLowerCase();
                        const stringB = String(valB).toLowerCase();
                        if (stringA < stringB) return sortDirection === 'asc' ? -1 : 1;
                        if (stringA > stringB) return sortDirection === 'asc' ? 1 : -1;
                        return 0;
                    }
                });
            }


            // Render rows for the current page
            const startIndex = (currentPage - 1) * rowsPerPage;
            const endIndex = startIndex + rowsPerPage;
            const pageData = sortedData.slice(startIndex, endIndex);

            if (pageData.length === 0) {
                 tableBody.innerHTML = '<tr><td colspan="100%">No data matches table filters on this page.</td></tr>';
            } else {
                pageData.forEach(rowData => {
                    const tr = document.createElement('tr');
                    headers.forEach(header => {
                        const td = document.createElement('td');
                        const cellValue = rowData[header] !== undefined && rowData[header] !== null ? rowData[header] : '';
                        td.textContent = cellValue;
                        td.title = String(cellValue); // Add title for ellipsis tooltip
                        tr.appendChild(td);
                    });
                    tableBody.appendChild(tr);
                });
            }


            // Update pagination controls
            const totalPages = Math.ceil(tableFilteredData.length / rowsPerPage);
            pageInfoSpan.textContent = `Page ${currentPage} of ${totalPages || 1}`;
            prevPageButton.disabled = currentPage === 1;
            nextPageButton.disabled = currentPage >= totalPages || totalPages === 0;
        }

         function handleTableFilterInput(e) {
             const input = e.target;
             const column = input.getAttribute('data-column');
             const filterValue = input.value.toLowerCase();

             // Update the tableHeaderFilters state
             tableHeaderFilters[column] = filterValue;

             // Debounce re-rendering the table
             clearTimeout(filterTimeout);
             filterTimeout = setTimeout(() => {
                 currentPage = 1; // Reset page on filter change
                 renderTable(); // Re-render table with new table header filter
             }, 300); // 300ms debounce
         }


        function handleSort(e) {
            const th = e.target.closest('th');
            if (!th) return;
            const column = th.getAttribute('data-column');
            if (!column) return;

            // Remove sort icons from all headers
            tableHeaderRow.querySelectorAll('.sort-icon').forEach(icon => {
                 icon.textContent = 'sort';
                 icon.style.opacity = '0.5';
            });
             tableHeaderRow.querySelectorAll('th').forEach(header => {
                 header.setAttribute('aria-sort', 'none');
            });


            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }

            // Update icon for the sorted column
            const sortIcon = th.querySelector('.sort-icon');
            if (sortIcon) {
                 sortIcon.textContent = sortDirection === 'asc' ? 'arrow_upward' : 'arrow_downward';
                 sortIcon.style.opacity = '1';
            }
             th.setAttribute('aria-sort', sortDirection === 'asc' ? 'ascending' : 'descending');


            currentPage = 1; // Reset page on sort change
            renderTable(); // Re-render table with new sort order
        }


        // --- Chart Rendering Functions ---

        function renderChart() {
            if (currentChart) {
                currentChart.destroy(); // Destroy previous chart instance
            }

            const dataColumn = chartDataSelect.value;

             if (filteredData.length === 0 || !dataColumn || !Object.keys(filteredData[0]).includes(dataColumn)) {
                 console.warn("No data or invalid column selected for chart.");
                 chartCanvas.style.display = 'none';
                 chartControls.classList.remove('active');
                 return;
             } else {
                 chartCanvas.style.display = 'block';
             }

            const chartType = chartTypeSelect.value;
            const dataValues = filteredData.map(row => row[dataColumn]);
             const columnType = inferColumnTypes(filteredData)[dataColumn] || 'text';


            let chartConfig = {};

            // Determine chart data based on column type and chart type
            if (chartType === 'bar') {
                 // Bar chart for categorical or numerical distribution
                 // For numerical, create bins or just count occurrences if few unique values
                 let labels, data;
                 if (columnType === 'numerical' && new Set(dataValues).size > 20) {
                     // Simple binning for numerical data with many unique values
                     const numericalValues = dataValues.map(parseFloat).filter(val => !isNaN(val));
                     if (numericalValues.length === 0) {
                          chartCanvas.style.display = 'none';
                          chartControls.classList.remove('active');
                          console.warn("No numerical data for bar chart.");
                          return;
                     }
                     const min = Math.min(...numericalValues);
                     const max = Math.max(...numericalValues);
                     const binCount = 10; // Arbitrary number of bins
                     const binSize = (max - min) / binCount;
                     const bins = Array(binCount).fill(0);
                     labels = Array(binCount).fill('').map((_, i) => `${(min + i * binSize).toFixed(1)}-${(min + (i + 1) * binSize).toFixed(1)}`);

                     numericalValues.forEach(val => {
                         let binIndex = Math.floor((val - min) / binSize);
                         if (binIndex >= binCount) binIndex = binCount - 1; // Handle max value edge case
                         if (binIndex < 0) binIndex = 0; // Handle min value edge case
                         bins[binIndex]++;
                     });
                     data = bins;

                 } else {
                     // Count occurrences for categorical, boolean, text, or numerical with few unique values
                     const counts = {};
                     dataValues.forEach(val => {
                         const key = String(val !== undefined && val !== null ? val : '(Empty)'); // Use string key, handle empty
                         counts[key] = (counts[key] || 0) + 1;
                     });
                     // Sort labels for consistency (optional)
                     labels = Object.keys(counts).sort();
                     data = labels.map(label => counts[label]);
                 }


                 chartConfig = {
                     type: 'bar',
                     data: {
                         labels: labels,
                         datasets: [{
                             label: `Count of ${dataColumn}`,
                             data: data,
                             backgroundColor: chartColorInput.value,
                             borderColor: chartColorInput.value.replace('rgb(', 'rgba(').replace(')', ', 0.8)'), // Slightly opaque border
                             borderWidth: 1
                         }]
                     },
                     options: {
                         responsive: true,
                         maintainAspectRatio: false,
                         plugins: {
                             legend: { display: false },
                             tooltip: { enabled: true }
                         },
                         scales: {
                             y: { beginAtZero: true, title: { display: true, text: 'Count' } },
                             x: { title: { display: true, text: columnType === 'numerical' ? `${dataColumn} (Bins)` : dataColumn } }
                         }
                     }
                 };
            } else if (chartType === 'pie') {
                 // Pie chart for categorical proportions
                  if (columnType !== 'categorical' && columnType !== 'boolean' && new Set(dataValues).size > 20) {
                      console.warn("Pie chart might be less readable for numerical or text data with many unique values.");
                  }
                 const counts = {};
                 dataValues.forEach(val => {
                      const key = String(val !== undefined && val !== null ? val : '(Empty)');
                     counts[key] = (counts[key] || 0) + 1;
                 });

                 const labels = Object.keys(counts).sort(); // Sort labels
                 const data = labels.map(label => counts[label]);

                 // Generate colors based on the selected color's hue
                 const baseColor = chartColorInput.value;
                 const baseHsl = rgbToHsl(baseColor);
                 const backgroundColors = Array.from({length: labels.length}, (_, i) => {
                     const hue = (baseHsl.h + (i * (300 / labels.length))) % 360; // Distribute hues, maybe less than 360 for similar palette
                     const saturation = 60 + (i % 3) * 10; // Vary saturation slightly
                     const lightness = 50 + (i % 2) * 10; // Vary lightness slightly
                     return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                 });
                 const borderColors = backgroundColors.map(color => color.replace('hsl(', 'hsla(').replace(')', ', 0.8)'));


                 chartConfig = {
                     type: 'pie',
                     data: {
                         labels: labels,
                         datasets: [{
                             label: `Proportion of ${dataColumn}`,
                             data: data,
                             backgroundColor: backgroundColors,
                             borderColor: borderColors,
                             borderWidth: 1
                         }]
                     },
                     options: {
                         responsive: true,
                         maintainAspectRatio: false,
                         plugins: {
                             legend: { position: 'top' },
                             tooltip: { enabled: true }
                         }
                     }
                 };
            } else if (chartType === 'line') {
                 // Line chart typically needs ordered data, like time series or sequence.
                 // For general survey data, this might not be meaningful unless a specific order column exists.
                  if (columnType !== 'numerical') {
                      console.warn("Line chart is best suited for numerical or time-series data.");
                       // Continue rendering but interpret with caution
                  }

                 // Simple example: plot numerical values in order of appearance
                 const numericalValues = dataValues.map(val => parseFloat(val)).filter(val => !isNaN(val));
                 const labels = Array.from({length: numericalValues.length}, (_, index) => `${index + 1}`); // Simple row index as label
                 const data = numericalValues;

                 if (data.length === 0) {
                      chartCanvas.style.display = 'none';
                      chartControls.classList.remove('active');
                      console.warn("No numerical data for line chart.");
                      return;
                 }

                 chartConfig = {
                     type: 'line',
                     data: {
                         labels: labels,
                         datasets: [{
                             label: dataColumn,
                             data: data,
                             borderColor: chartColorInput.value,
                             backgroundColor: chartColorInput.value.replace('rgb(', 'rgba(').replace(')', ', 0.2)'), // Semi-transparent fill
                             borderWidth: 2,
                             fill: true,
                             tension: 0.1 // Add some curve
                         }]
                     },
                     options: {
                         responsive: true,
                         maintainAspectRatio: false,
                          plugins: {
                             legend: { display: false },
                             tooltip: { enabled: true }
                         },
                         scales: {
                             y: { beginAtZero: true, title: { display: true, text: dataColumn } },
                             x: { title: { display: true, text: 'Record Index' } }
                         }
                     }
                 };
            }
            // Add more chart types here (e.g., scatter, histogram)

             // Apply font size from controls globally
             const fontSize = parseInt(chartFontSizeInput.value);
             Chart.defaults.font.size = fontSize;
             Chart.defaults.plugins.legend.labels.font.size = fontSize;
             Chart.defaults.plugins.tooltip.bodyFont.size = fontSize;
             Chart.defaults.plugins.tooltip.titleFont.size = fontSize;
             Chart.defaults.scales.linear.ticks.font.size = fontSize;
             Chart.defaults.scales.category.ticks.font.size = fontSize;


            const ctx = chartCanvas.getContext('2d');
            currentChart = new Chart(ctx, chartConfig);
        }


        function updateChartControls() {
            if (!currentChart) return;

            const newColor = chartColorInput.value;
            const newFontSize = parseInt(chartFontSizeInput.value);

            // Update colors based on chart type
            if (currentChart.config.type === 'bar' || currentChart.config.type === 'line') {
                 currentChart.config.data.datasets[0].borderColor = newColor;
                 if (currentChart.config.type === 'bar') {
                     currentChart.config.data.datasets[0].backgroundColor = newColor;
                 } else { // line
                     currentChart.config.data.datasets[0].backgroundColor = newColor.replace('rgb(', 'rgba(').replace(')', ', 0.2)');
                 }
            } else if (currentChart.config.type === 'pie') {
                // Regenerate colors based on the selected color's hue
                 const baseColor = newColor;
                 const baseHsl = rgbToHsl(baseColor);
                 const numSegments = currentChart.config.data.labels.length;
                 const newBackgroundColors = Array.from({length: numSegments}, (_, i) => {
                     const hue = (baseHsl.h + (i * (300 / numSegments))) % 360; // Distribute hues
                     const saturation = 60 + (i % 3) * 10; // Vary saturation slightly
                     const lightness = 50 + (i % 2) * 10; // Vary lightness slightly
                     return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                 });
                 const newBorderColors = newBackgroundColors.map(color => color.replace('hsl(', 'hsla(').replace(')', ', 0.8)'));
                 currentChart.config.data.datasets[0].backgroundColor = newBackgroundColors;
                 currentChart.config.data.datasets[0].borderColor = newBorderColors;
            }

            // Update font size - Chart.js v3+ uses global defaults or options per element
            // Update global default font size and specific defaults
            Chart.defaults.font.size = newFontSize;
            Chart.defaults.plugins.legend.labels.font.size = newFontSize;
            Chart.defaults.plugins.tooltip.bodyFont.size = newFontSize;
            Chart.defaults.plugins.tooltip.titleFont.size = newFontSize;
            Chart.defaults.scales.linear.ticks.font.size = newFontSize;
            Chart.defaults.scales.category.ticks.font.size = newFontSize;

            // Re-render the chart to ensure font size changes are applied correctly everywhere
             renderChart();
        }

        // Helper to convert RGB hex to HSL for color variations
        function rgbToHsl(hex) {
            let r = 0, g = 0, b = 0;
            // Handle short hex format (#rgb)
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            }
            // Handle long hex format (#rrggbb)
            else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            } else {
                // Invalid hex, return default HSL (e.g., for #007bff)
                 console.warn("Invalid hex color format:", hex);
                 return { h: 210, s: 100, l: 50 }; // Default for #007bff
            }

            r /= 255;
            g /= 255;
            b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return { h: h * 360, s: s * 100, l: l * 100 };
        }


        // --- Export Functions ---

        function exportCSV() {
            if (filteredData.length === 0) {
                alert("No data to export based on current filters.");
                return;
            }

            // Use PapaParse to unparse the filtered data (analysis filters applied)
            const csv = parse(filteredData, {
                header: true,
                quotes: true // Add quotes around fields
            });

            const blob = new Blob([csv.data], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'survey_data_filtered.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
             URL.revokeObjectURL(url); // Clean up object URL
        }

        function exportChartPNG() {
             if (!currentChart) {
                 alert("No chart to export.");
                 return;
            }

            const link = document.createElement('a');
            link.download = 'chart.png';
            link.href = chartCanvas.toDataURL('image/png');
            link.click();
        }


        // --- UI State Management ---

        function showSection(sectionId) {
            // Hide all main sections
            document.querySelectorAll('main section').forEach(section => {
                section.classList.add('hidden');
            });

            // Show the requested section
            if (sectionId === 'upload') {
                uploadSection.classList.remove('hidden');
            } else if (sectionId === 'analysis') {
                 // The analysis section contains table, controls, summary, visualization
                analysisSection.classList.remove('hidden');
                // Ensure data table part is visible within analysis
                dataTableSection.classList.remove('hidden');
            }
            // Add more sections if needed

            // Update active navigation link
            document.querySelectorAll('.sidebar nav ul li a').forEach(link => {
                link.classList.remove('active');
            });
            const activeLink = document.getElementById(`nav-${sectionId}`);
             // Special case: nav-data links to analysis section
             if (sectionId === 'analysis') {
                 document.getElementById('nav-analysis').classList.add('active');
                 document.getElementById('nav-data').classList.add('active'); // Also highlight data link
             } else if (activeLink) {
                 activeLink.classList.add('active');
             }
        }

        // Initial state: show upload section
        showSection('upload');

    </script>

</body>
</html>
