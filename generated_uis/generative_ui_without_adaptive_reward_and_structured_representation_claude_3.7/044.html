<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>French Vocabulary Learner</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,400,0..1,-25..200" rel="stylesheet" />
    <style>
        :root {
            --primary-color: #5E35B1; /* Deep Purple */
            --primary-color-light: #7E57C2;
            --primary-color-dark: #4527A0;
            --secondary-color: #FFCA28; /* Amber */
            --secondary-color-dark: #FFA000;
            --text-color: #212121; /* Dark Grey */
            --text-color-light: #757575; /* Grey */
            --background-color: #FFFFFF; /* White */
            --surface-color: #F5F5F5; /* Light Grey */
            --success-color: #66BB6A; /* Green */
            --error-color: #EF5350; /* Red */
            --border-radius: 8px;
            --spacing-unit: 8px;
            --header-height: 60px;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--surface-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-y: auto;
        }

        header {
            background-color: var(--primary-color);
            color: var(--background-color);
            padding: 0 calc(var(--spacing-unit) * 4);
            height: var(--header-height);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: fixed;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 1000;
        }

        header h1 {
            margin: 0;
            font-size: 1.5em;
            font-weight: 700;
        }

        nav ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            gap: calc(var(--spacing-unit) * 3);
        }

        nav li {
            margin: 0;
        }

        nav a {
            color: var(--background-color);
            text-decoration: none;
            font-weight: 500;
            padding: calc(var(--spacing-unit) * 2) 0;
            position: relative;
            transition: color 0.2s ease;
            outline-offset: 4px; /* For keyboard focus */
        }

        nav a::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -2px;
            width: 100%;
            height: 2px;
            background-color: var(--secondary-color);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        nav a:hover::after,
        nav a.active::after {
            transform: scaleX(1);
        }

        nav a:hover {
             color: var(--secondary-color);
        }

        nav a:focus {
            outline: 2px solid var(--secondary-color);
        }


        main {
            flex-grow: 1;
            padding: calc(var(--spacing-unit) * 4);
            padding-top: calc(var(--header-height) + var(--spacing-unit) * 4); /* Add padding to account for fixed header */
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: calc(var(--spacing-unit) * 4);
        }

        .view {
            display: none;
            animation: fadeIn 0.5s ease-out forwards;
        }

        .view.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h2 {
            font-size: 2em;
            font-weight: 700;
            color: var(--primary-color-dark);
            margin-bottom: calc(var(--spacing-unit) * 3);
            text-align: center;
        }

        .card {
            background-color: var(--background-color);
            border-radius: var(--border-radius);
            padding: calc(var(--spacing-unit) * 3);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* Vocabulary List View */
        .vocabulary-list-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: calc(var(--spacing-unit) * 3);
        }

        .vocabulary-set-card {
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 120px;
            outline-offset: 4px;
        }

        .vocabulary-set-card:focus {
             outline: 2px solid var(--secondary-color-dark);
        }

        .vocabulary-set-card h3 {
            margin: 0 0 var(--spacing-unit);
            font-size: 1.2em;
            font-weight: 600;
            color: var(--primary-color);
        }

        .vocabulary-set-card p {
            margin: 0;
            color: var(--text-color-light);
            font-size: 0.9em;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background-color: var(--surface-color);
            border-radius: 4px;
            overflow: hidden;
            margin-top: calc(var(--spacing-unit) * 2);
        }

        .progress-bar {
            height: 100%;
            background-color: var(--success-color);
            width: 0%;
            transition: width 0.4s ease-in-out;
        }

        /* Vocabulary Detail View */
        .vocabulary-detail-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .vocabulary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(var(--spacing-unit) * 2) 0;
            border-bottom: 1px solid #eee;
        }

        .vocabulary-item:last-child {
            border-bottom: none;
        }

        .vocabulary-item span {
            flex-grow: 1;
            margin-right: calc(var(--spacing-unit) * 2);
        }

        .vocabulary-item .word {
            font-weight: 600;
            color: var(--primary-color-dark);
        }

        .vocabulary-item .translation {
            color: var(--text-color);
        }

        .vocabulary-item .translation.hidden {
            filter: blur(3px);
        }

        .audio-button {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--primary-color);
            font-size: 1.5em;
            padding: var(--spacing-unit);
            border-radius: 50%;
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevent shrinking */
            outline-offset: 4px;
        }

        .audio-button:hover {
            background-color: rgba(var(--primary-color-light), 0.1);
            color: var(--primary-color-dark);
        }
        .audio-button:focus {
             outline: 2px solid var(--secondary-color-dark);
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .audio-button .material-symbols-rounded {
             animation: none; /* Reset animation */
        }

        .audio-button.playing .material-symbols-rounded {
             animation: pulse 0.5s ease-out;
        }


        .toggle-translation-button {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: none;
            padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 3);
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: background-color 0.2s ease;
            margin-top: calc(var(--spacing-unit) * 3);
            display: block;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            outline-offset: 4px;
        }

        .toggle-translation-button:hover {
            background-color: var(--secondary-color-dark);
        }
         .toggle-translation-button:focus {
             outline: 2px solid var(--primary-color-dark);
         }


        /* Exercise Selection View */
        .exercise-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: calc(var(--spacing-unit) * 3);
        }

        .exercise-type-card {
            cursor: pointer;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 150px;
            outline-offset: 4px;
        }
         .exercise-type-card:focus {
             outline: 2px solid var(--secondary-color-dark);
         }


        .exercise-type-card .material-symbols-rounded {
            font-size: 3em;
            color: var(--primary-color);
            margin-bottom: var(--spacing-unit);
        }

        .exercise-type-card h3 {
            margin: 0;
            font-size: 1.1em;
            font-weight: 600;
            color: var(--primary-color-dark);
        }

        /* Exercise Views (General) */
        .exercise-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: calc(var(--spacing-unit) * 3);
        }

        .exercise-area {
            background-color: var(--background-color);
            border-radius: var(--border-radius);
            padding: calc(var(--spacing-unit) * 4);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            width: 100%;
            max-width: 600px;
            text-align: center;
        }

        .exercise-feedback {
            margin-top: calc(var(--spacing-unit) * 2);
            padding: calc(var(--spacing-unit) * 1.5);
            border-radius: var(--border-radius);
            font-weight: 600;
            min-height: 20px; /* Reserve space */
            text-align: center;
        }

        .exercise-feedback.success {
            background-color: #E8F5E9; /* Light Green */
            color: var(--success-color);
        }

        .exercise-feedback.error {
            background-color: #FFEBEE; /* Light Red */
            color: var(--error-color);
        }

        .exercise-controls {
            display: flex;
            justify-content: center;
            gap: calc(var(--spacing-unit) * 2);
            margin-top: calc(var(--spacing-unit) * 3);
        }

        .button {
            background-color: var(--primary-color);
            color: var(--background-color);
            border: none;
            padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 3);
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: background-color 0.2s ease;
            outline-offset: 4px;
        }

        .button:hover {
            background-color: var(--primary-color-light);
        }

        .button:focus {
             outline: 2px solid var(--secondary-color-dark);
        }

        .button:disabled {
            background-color: #BDBDBD; /* Grey */
            cursor: not-allowed;
            opacity: 0.6;
        }

        .button.secondary {
            background-color: var(--secondary-color);
            color: var(--text-color);
        }

        .button.secondary:hover {
            background-color: var(--secondary-color-dark);
        }
         .button.secondary:focus {
             outline: 2px solid var(--primary-color-dark);
         }


        /* Flashcard Exercise */
        .flashcard {
            width: 100%;
            max-width: 400px; /* Max width for flashcard */
            height: 250px;
            perspective: 1000px;
        }

        .flashcard-inner {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
        }

        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }

        .flashcard-front,
        .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: var(--background-color);
            border-radius: var(--border-radius);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            padding: calc(var(--spacing-unit) * 3);
            text-align: center;
            user-select: none; /* Prevent text selection during flip */
        }

        .flashcard-front {
            font-size: 2em;
            font-weight: 700;
            color: var(--primary-color-dark);
        }

        .flashcard-back {
            transform: rotateY(180deg);
            font-size: 1.5em;
            color: var(--text-color);
            justify-content: space-around;
        }

        .flashcard-back .translation {
             font-weight: 600;
        }

        .flashcard-back .audio-button {
             font-size: 1.8em;
        }

        .flashcard-feedback-buttons {
            display: flex;
            gap: calc(var(--spacing-unit) * 2);
            margin-top: calc(var(--spacing-unit) * 2);
            width: 100%; /* Ensure buttons take full width */
        }

        .flashcard-feedback-buttons .button {
            flex: 1;
        }

        .flashcard-feedback-buttons .button.success {
            background-color: var(--success-color);
        }
        .flashcard-feedback-buttons .button.success:hover {
            background-color: #4CAF50; /* Darker Green */
        }
         .flashcard-feedback-buttons .button.success:focus {
             outline: 2px solid var(--primary-color-dark);
         }

        .flashcard-feedback-buttons .button.error {
            background-color: var(--error-color);
        }
         .flashcard-feedback-buttons .button.error:hover {
            background-color: #D32F2F; /* Darker Red */
        }
         .flashcard-feedback-buttons .button.error:focus {
             outline: 2px solid var(--primary-color-dark);
         }


        /* Matching Exercise */
        .matching-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: calc(var(--spacing-unit) * 3);
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            position: relative; /* For drawing lines */
        }

        .matching-column {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: calc(var(--spacing-unit) * 2);
        }

        .matching-item {
            background-color: var(--surface-color);
            padding: calc(var(--spacing-unit) * 2);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, border-color 0.2s ease;
            text-align: center;
            font-weight: 500;
            border: 2px solid transparent;
            outline-offset: 4px;
        }

        .matching-item:hover {
            background-color: #E0E0E0; /* Grey 300 */
        }
         .matching-item:focus {
             outline: 2px solid var(--primary-color-dark);
         }


        .matching-item.selected {
            border-color: var(--primary-color);
            background-color: #E1BEE7; /* Purple 100 */
        }

        .matching-item.matched {
            background-color: #C8E6C9; /* Green 100 */
            border-color: var(--success-color);
            cursor: default;
            pointer-events: none; /* Disable clicks on matched items */
        }

         .matching-item.incorrect {
            background-color: #FFCDD2; /* Red 100 */
            border-color: var(--error-color);
             animation: shake 0.5s;
         }

        @keyframes shake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }

        .matching-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks on items below */
            z-index: 1;
        }


        /* Fill-in-the-Blank Exercise */
        .fill-in-the-blank-sentence {
            font-size: 1.4em;
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        .fill-in-the-blank-sentence input {
            font-size: 1em;
            padding: calc(var(--spacing-unit) * 1.5);
            margin: 0 var(--spacing-unit);
            border: 2px solid var(--surface-color);
            border-radius: var(--border-radius);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            outline: none; /* Remove default outline */
        }

        .fill-in-the-blank-sentence input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(var(--primary-color), 0.2);
        }

        .fill-in-the-blank-sentence input.correct {
             border-color: var(--success-color);
             box-shadow: 0 0 0 3px rgba(var(--success-color), 0.2);
        }

         .fill-in-the-blank-sentence input.incorrect {
             border-color: var(--error-color);
             box-shadow: 0 0 0 3px rgba(var(--error-color), 0.2);
         }


        /* Quiz Exercise */
        .quiz-question {
            font-size: 1.4em;
            margin-bottom: calc(var(--spacing-unit) * 3);
            font-weight: 600;
        }

        .quiz-options {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: calc(var(--spacing-unit) * 2);
        }

        .quiz-option-button {
            width: 100%;
            background-color: var(--surface-color);
            border: 2px solid var(--surface-color);
            padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 2);
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1em;
            text-align: left;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
            outline-offset: 4px;
        }

        .quiz-option-button:hover {
            background-color: #E0E0E0; /* Grey 300 */
        }
         .quiz-option-button:focus {
             outline: 2px solid var(--primary-color-dark);
         }


        .quiz-option-button.selected {
             border-color: var(--primary-color);
             background-color: #E1BEE7; /* Purple 100 */
        }

        .quiz-option-button.correct {
            background-color: #C8E6C9; /* Green 100 */
            border-color: var(--success-color);
        }

        .quiz-option-button.incorrect {
            background-color: #FFCDD2; /* Red 100 */
            border-color: var(--error-color);
        }
         .quiz-option-button:disabled {
             cursor: default;
         }


        /* Progress View */
        .progress-summary {
            text-align: center;
            margin-bottom: calc(var(--spacing-unit) * 4);
        }

        .progress-summary h3 {
            font-size: 1.8em;
            color: var(--primary-color-dark);
            margin-bottom: var(--spacing-unit);
        }

        .progress-summary p {
            font-size: 1.1em;
            color: var(--text-color-light);
        }

        .progress-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: calc(var(--spacing-unit) * 2);
        }

        .progress-item {
            background-color: var(--background-color);
            border-radius: var(--border-radius);
            padding: calc(var(--spacing-unit) * 2);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .progress-item span {
            font-weight: 500;
        }

        .progress-item .progress-percentage {
            font-weight: 700;
            color: var(--success-color);
        }

         /* Utility Classes */
        .text-center { text-align: center; }
        .mb-3 { margin-bottom: calc(var(--spacing-unit) * 3); }
        .mt-3 { margin-top: calc(var(--spacing-unit) * 3); }


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            header {
                padding: 0 calc(var(--spacing-unit) * 2);
            }

            nav ul {
                gap: calc(var(--spacing-unit) * 1.5);
            }

            main {
                padding: calc(var(--spacing-unit) * 2);
                padding-top: calc(var(--header-height) + var(--spacing-unit) * 2);
            }

            h2 {
                font-size: 1.6em;
            }

            .vocabulary-list-grid,
            .exercise-selection-grid {
                grid-template-columns: 1fr;
            }

            .matching-columns {
                grid-template-columns: 1fr;
            }

            .matching-column {
                gap: var(--spacing-unit);
            }

            .matching-item {
                padding: calc(var(--spacing-unit) * 1.5);
            }

            .fill-in-the-blank-sentence input {
                margin: 0 calc(var(--spacing-unit) * 0.5);
                padding: var(--spacing-unit);
            }

            .button {
                padding: calc(var(--spacing-unit) * 1.2) calc(var(--spacing-unit) * 2);
            }
        }

        @media (max-width: 480px) {
             header h1 {
                 font-size: 1.2em;
             }
             nav a {
                 font-size: 0.9em;
             }
             main {
                 padding: var(--spacing-unit);
                 padding-top: calc(var(--header-height) + var(--spacing-unit));
             }
             .card {
                 padding: calc(var(--spacing-unit) * 2);
             }
             .vocabulary-set-card h3 {
                 font-size: 1.1em;
             }
             .vocabulary-item {
                 padding: calc(var(--spacing-unit) * 1.5) 0;
             }
             .vocabulary-item .word,
             .vocabulary-item .translation {
                 font-size: 0.95em;
             }
             .audio-button {
                 font-size: 1.3em;
             }
             .toggle-translation-button {
                 padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
                 font-size: 0.9em;
             }
             .exercise-area {
                 padding: calc(var(--spacing-unit) * 3);
             }
             .flashcard-front {
                 font-size: 1.8em;
             }
             .flashcard-back {
                 font-size: 1.3em;
             }
             .flashcard-feedback-buttons {
                 flex-direction: column;
             }
             .fill-in-the-blank-sentence {
                 font-size: 1.2em;
             }
             .fill-in-the-blank-sentence input {
                 font-size: 0.9em;
             }
             .quiz-question {
                 font-size: 1.2em;
             }
             .quiz-option-button {
                 font-size: 0.95em;
             }
        }

    </style>
</head>
<body>
    <header>
        <h1>French Learner</h1>
        <nav aria-label="Main navigation">
            <ul>
                <li><a href="#" data-view="home" class="active" aria-label="Go to Home page">Home</a></li>
                <li><a href="#" data-view="vocabulary-list" aria-label="View Vocabulary Sets">Vocabulary</a></li>
                <li><a href="#" data-view="progress" aria-label="View Your Progress">Progress</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section id="home-view" class="view active" role="region" aria-labelledby="home-heading">
            <div class="card text-center">
                <h2 id="home-heading">Welcome to French Learner!</h2>
                <p>Expand your French vocabulary through interactive exercises.</p>
                <p>Start by exploring the vocabulary sets or jump straight into exercises.</p>
                <div class="exercise-controls mt-3">
                     <button class="button" data-navigate="vocabulary-list" aria-label="Explore Vocabulary Sets">Explore Vocabulary</button>
                     <button class="button secondary" data-navigate="exercise-selection" aria-label="Start Exercises">Start Exercises</button>
                </div>
            </div>
        </section>

        <section id="vocabulary-list-view" class="view" role="region" aria-labelledby="vocabulary-list-heading">
            <h2 id="vocabulary-list-heading">Vocabulary Sets</h2>
            <div id="vocabulary-list-container" class="vocabulary-list-grid" role="list">
                <!-- Vocabulary set cards will be rendered here by JS -->
            </div>
        </section>

         <section id="vocabulary-detail-view" class="view" role="region" aria-labelledby="detail-set-title">
            <h2 id="detail-set-title"></h2>
            <div class="card">
                <ul id="vocabulary-detail-list" class="vocabulary-detail-list" role="list">
                    <!-- Vocabulary items will be rendered here by JS -->
                </ul>
                <button id="toggle-translation-button" class="toggle-translation-button" aria-controls="vocabulary-detail-list">Hide Translations</button>
            </div>
             <div class="exercise-controls mt-3">
                 <button class="button" data-navigate="exercise-selection" aria-label="Practice this Vocabulary Set">Practice this Set</button>
             </div>
        </section>

         <section id="exercise-selection-view" class="view" role="region" aria-labelledby="exercise-selection-title">
            <h2 id="exercise-selection-title">Choose an Exercise</h2>
             <p class="text-center mb-3">Select an exercise type to practice the vocabulary from <strong id="selected-set-name"></strong>.</p>
            <div class="exercise-selection-grid" role="list">
                 <div class="card exercise-type-card" data-exercise="flashcard" tabindex="0" role="button" aria-label="Start Flashcard Exercise">
                    <span class="material-symbols-rounded" aria-hidden="true">style</span>
                    <h3>Flashcards</h3>
                    <p>Flip cards to reveal translations.</p>
                 </div>
                 <div class="card exercise-type-card" data-exercise="matching" tabindex="0" role="button" aria-label="Start Matching Exercise">
                    <span class="material-symbols-rounded" aria-hidden="true">link</span>
                    <h3>Matching</h3>
                    <p>Match French words with their English translations.</p>
                 </div>
                 <div class="card exercise-type-card" data-exercise="fill-in-the-blank" tabindex="0" role="button" aria-label="Start Fill in the Blank Exercise">
                    <span class="material-symbols-rounded" aria-hidden="true">edit_square</span>
                    <h3>Fill in the Blank</h3>
                    <p>Complete sentences with the correct word.</p>
                 </div>
                 <div class="card exercise-type-card" data-exercise="quiz" tabindex="0" role="button" aria-label="Start Quiz Exercise">
                    <span class="material-symbols-rounded" aria-hidden="true">quiz</span>
                    <h3>Quiz</h3>
                    <p>Test your knowledge with multiple choice questions.</p>
                 </div>
            </div>
        </section>

        <section id="flashcard-exercise-view" class="view" role="region" aria-labelledby="flashcard-set-title">
             <h2 id="flashcard-set-title">Flashcards</h2>
             <p class="text-center mb-3">Set: <strong id="flashcard-set-name"></strong></p>
             <div class="exercise-container">
                 <div class="flashcard" id="flashcard-container" role="button" aria-live="polite" aria-atomic="true">
                     <div class="flashcard-inner">
                         <div class="flashcard-front" aria-hidden="false">
                             <span id="flashcard-word"></span>
                         </div>
                         <div class="flashcard-back" aria-hidden="true">
                             <span id="flashcard-translation"></span>
                             <button class="audio-button" id="flashcard-audio-button" aria-label="Play pronunciation">
                                 <span class="material-symbols-rounded" aria-hidden="true">volume_up</span>
                             </button>
                             <div class="flashcard-feedback-buttons">
                                 <button class="button success" id="flashcard-know-button" aria-label="Mark as Known">Know</button>
                                 <button class="button error" id="flashcard-dont-know-button" aria-label="Mark as Unknown">Don't Know</button>
                             </div>
                         </div>
                     </div>
                 </div>
                 <div class="exercise-controls">
                     <button class="button" id="flashcard-next-button" aria-label="Next Flashcard">Next Card</button>
                 </div>
                 <div id="flashcard-feedback" class="exercise-feedback" role="status" aria-live="polite"></div>
             </div>
        </section>

         <section id="matching-exercise-view" class="view" role="region" aria-labelledby="matching-set-title">
             <h2 id="matching-set-title">Matching</h2>
             <p class="text-center mb-3">Set: <strong id="matching-set-name"></strong></p>
             <div class="exercise-container">
                 <div class="matching-columns" id="matching-columns">
                     <ul class="matching-column" id="matching-french-column" role="listbox" aria-label="French words">
                         <!-- French words -->
                     </ul>
                     <ul class="matching-column" id="matching-english-column" role="listbox" aria-label="English translations">
                         <!-- English translations -->
                     </ul>
                      <canvas id="matching-canvas" class="matching-canvas" aria-hidden="true"></canvas>
                 </div>
                 <div class="exercise-controls">
                     <button class="button" id="matching-check-button" aria-label="Check Matches">Check Matches</button>
                     <button class="button secondary" id="matching-next-button" disabled aria-label="Go to Next Set">Next Set</button>
                 </div>
                 <div id="matching-feedback" class="exercise-feedback" role="status" aria-live="polite"></div>
             </div>
        </section>

         <section id="fill-in-the-blank-exercise-view" class="view" role="region" aria-labelledby="fill-in-set-title">
            <h2 id="fill-in-set-title">Fill in the Blank</h2>
            <p class="text-center mb-3">Set: <strong id="fill-in-set-name"></strong></p>
             <div class="exercise-container">
                 <div class="exercise-area">
                     <div id="fill-in-sentence" class="fill-in-the-blank-sentence" role="text" aria-live="polite" aria-atomic="true">
                         <!-- Sentence with input will be rendered here -->
                     </div>
                 </div>
                 <div class="exercise-controls">
                     <button class="button" id="fill-in-check-button" aria-label="Check Answer">Check Answer</button>
                     <button class="button secondary" id="fill-in-next-button" disabled aria-label="Go to Next Word">Next Word</button>
                 </div>
                 <div id="fill-in-feedback" class="exercise-feedback" role="status" aria-live="polite"></div>
             </div>
        </section>

         <section id="quiz-exercise-view" class="view" role="region" aria-labelledby="quiz-set-title">
             <h2 id="quiz-set-title">Quiz</h2>
             <p class="text-center mb-3">Set: <strong id="quiz-set-name"></strong></p>
             <div class="exercise-container">
                 <div class="exercise-area">
                     <div id="quiz-question" class="quiz-question" role="text" aria-live="polite" aria-atomic="true">
                         <!-- Quiz question will be rendered here -->
                     </div>
                     <ul id="quiz-options" class="quiz-options" role="radiogroup" aria-labelledby="quiz-question">
                         <!-- Quiz options will be rendered here -->
                     </ul>
                 </div>
                 <div class="exercise-controls">
                     <button class="button" id="quiz-submit-button" aria-label="Submit Answer">Submit Answer</button>
                     <button class="button secondary" id="quiz-next-button" disabled aria-label="Go to Next Question">Next Question</button>
                 </div>
                 <div id="quiz-feedback" class="exercise-feedback" role="status" aria-live="polite"></div>
             </div>
        </section>


        <section id="progress-view" class="view" role="region" aria-labelledby="progress-heading">
            <h2 id="progress-heading">Your Progress</h2>
            <div class="card progress-summary">
                 <h3>Overall Progress</h3>
                 <p>Total Words Known: <span id="overall-known-count">0</span> / <span id="overall-total-count">0</span> (<span id="overall-percentage">0</span>%)</p>
            </div>
            <div class="card">
                <h3>Progress by Set</h3>
                <ul id="progress-list" class="progress-list" role="list">
                    <!-- Progress items will be rendered here by JS -->
                </ul>
            </div>
        </section>

    </main>

    <script>
        // --- Data ---
        const vocabularyData = [
            {
                id: 'greetings',
                name: 'Greetings',
                description: 'Basic ways to say hello and goodbye.',
                words: [
                    { french: 'Bonjour', english: 'Hello / Good morning' },
                    { french: 'Bonsoir', english: 'Good evening' },
                    { french: 'Salut', english: 'Hi / Bye (informal)' },
                    { french: 'Au revoir', english: 'Goodbye' },
                    { french: 'À bientôt', english: 'See you soon' },
                    { french: 'À plus tard', english: 'See you later' },
                ]
            },
            {
                id: 'basic-phrases',
                name: 'Basic Phrases',
                description: 'Essential phrases for conversation.',
                words: [
                    { french: 'Oui', english: 'Yes' },
                    { french: 'Non', english: 'No' },
                    { french: 'S\'il vous plaît', english: 'Please (formal)' },
                    { french: 'S\'il te plaît', english: 'Please (informal)' },
                    { french: 'Merci', english: 'Thank you' },
                    { french: 'De rien', english: 'You\'re welcome' },
                    { french: 'Excusez-moi', english: 'Excuse me (formal)' },
                    { french: 'Excuse-moi', english: 'Excuse me (informal)' },
                    { french: 'Pardon', english: 'Sorry / Excuse me' },
                    { french: 'Je suis désolé(e)', english: 'I am sorry' },
                    { french: 'Comment ça va ?', english: 'How are you? (informal)' },
                    { french: 'Ça va bien, merci', english: 'I\'m fine, thank you' },
                    { french: 'Et vous ?', english: 'And you? (formal)' },
                    { french: 'Et toi ?', english: 'And you? (informal)' },
                ]
            },
             {
                id: 'numbers-1-10',
                name: 'Numbers 1-10',
                description: 'Counting from one to ten.',
                words: [
                    { french: 'Un', english: 'One' },
                    { french: 'Deux', english: 'Two' },
                    { french: 'Trois', english: 'Three' },
                    { french: 'Quatre', english: 'Four' },
                    { french: 'Cinq', english: 'Five' },
                    { french: 'Six', english: 'Six' },
                    { french: 'Sept', english: 'Seven' },
                    { french: 'Huit', english: 'Eight' },
                    { french: 'Neuf', english: 'Nine' },
                    { french: 'Dix', english: 'Ten' },
                ]
            },
        ];

        // --- State Management ---
        const state = {
            currentView: 'home',
            selectedSetId: null,
            selectedSet: null,
            progress: {}, // { setId: { total: N, known: K, unknown: U } }
            currentExercise: null, // 'flashcard', 'matching', 'fill-in-the-blank', 'quiz'
            exerciseData: [], // Shuffled words for the current exercise
            exerciseIndex: 0,
            matchingPairs: [], // For matching exercise: [{frenchElement: element, englishElement: element}] - Store elements directly for drawing
            matchingSelected: null, // { type: 'french' | 'english', element: element, wordIndex: i }
            fillInWord: null, // For fill-in-the-blank: { french: '...', english: '...', inputElement: element }
            quizWord: null, // For quiz: { french: '...', english: '...' }
            quizOptions: [], // For quiz: ['option1', 'option2', ...]
            quizCorrectAnswer: null, // For quiz: 'Correct Answer'
        };

        // Load progress from local storage
        function loadProgress() {
            const savedProgress = localStorage.getItem('frenchLearnerProgress');
            if (savedProgress) {
                state.progress = JSON.parse(savedProgress);
            }

            // Initialize or update progress structure for all sets
            vocabularyData.forEach(set => {
                if (!state.progress[set.id]) {
                     state.progress[set.id] = {
                         total: set.words.length,
                         known: 0,
                         unknown: 0
                     };
                } else {
                     // Ensure total is up-to-date if vocabulary data changes
                     state.progress[set.id].total = set.words.length;
                     // Ensure known/unknown don't exceed total (can happen if words are removed)
                     state.progress[set.id].known = Math.min(state.progress[set.id].known, set.words.length);
                     state.progress[set.id].unknown = Math.min(state.progress[set.id].unknown, set.words.length - state.progress[set.id].known);
                }
            });
            saveProgress(); // Save immediately after ensuring structure is correct
        }

        // Save progress to local storage
        function saveProgress() {
            localStorage.setItem('frenchLearnerProgress', JSON.stringify(state.progress));
        }

        // --- DOM Manipulation / Rendering ---
        const views = document.querySelectorAll('.view');
        const navLinks = document.querySelectorAll('nav a');

        function showView(viewId) {
            views.forEach(view => {
                view.classList.remove('active');
                view.setAttribute('aria-hidden', 'true'); // Hide from screen readers
            });
            const activeView = document.getElementById(viewId);
            activeView.classList.add('active');
            activeView.setAttribute('aria-hidden', 'false'); // Show to screen readers


            navLinks.forEach(link => {
                if (link.dataset.view === viewId.replace('-view', '')) {
                    link.classList.add('active');
                    link.setAttribute('aria-current', 'page');
                } else {
                    link.classList.remove('active');
                    link.removeAttribute('aria-current');
                }
            });

            state.currentView = viewId.replace('-view', '');
            // Scroll to top when changing view
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function renderVocabularyList() {
            const container = document.getElementById('vocabulary-list-container');
            container.innerHTML = ''; // Clear previous content

            vocabularyData.forEach(set => {
                const setProgress = state.progress[set.id] || { total: set.words.length, known: 0, unknown: 0 };
                const progressPercentage = setProgress.total > 0 ? Math.round((setProgress.known / setProgress.total) * 100) : 0;

                const card = document.createElement('div');
                card.classList.add('card', 'vocabulary-set-card');
                card.dataset.setId = set.id;
                card.setAttribute('role', 'listitem');
                card.setAttribute('tabindex', '0'); // Make card focusable
                 card.setAttribute('aria-label', `Vocabulary set: ${set.name}. ${progressPercentage}% known.`);

                card.innerHTML = `
                    <h3>${set.name}</h3>
                    <p>${set.description}</p>
                    <div class="progress-bar-container">
                        <div class="progress-bar" style="width: ${progressPercentage}%;" role="progressbar" aria-valuenow="${progressPercentage}" aria-valuemin="0" aria-valuemax="100" aria-label="Progress for ${set.name}"></div>
                    </div>
                    <p style="font-size:0.8em; text-align: right; margin-top: calc(var(--spacing-unit) * 1px);">${progressPercentage}% Known</p>
                `;
                container.appendChild(card);
            });

            // Add event listeners to cards
            container.querySelectorAll('.vocabulary-set-card').forEach(card => {
                card.addEventListener('click', handleSetCardClick);
                card.addEventListener('keypress', (event) => {
                     if (event.key === 'Enter' || event.key === ' ') {
                         handleSetCardClick(event);
                     }
                });
            });
        }

        function handleSetCardClick(event) {
             const card = event.currentTarget;
             state.selectedSetId = card.dataset.setId;
             state.selectedSet = vocabularyData.find(set => set.id === state.selectedSetId);
             renderVocabularyDetail();
             showView('vocabulary-detail-view');
        }


        function renderVocabularyDetail() {
            const title = document.getElementById('detail-set-title');
            const list = document.getElementById('vocabulary-detail-list');
            const toggleButton = document.getElementById('toggle-translation-button');

            title.textContent = state.selectedSet.name;
            list.innerHTML = ''; // Clear previous content

            state.selectedSet.words.forEach((word, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('vocabulary-item');
                listItem.setAttribute('role', 'listitem');
                listItem.innerHTML = `
                    <span class="word" lang="fr">${word.french}</span>
                    <span class="translation">${word.english}</span>
                    <button class="audio-button" data-word="${word.french}" aria-label="Play pronunciation for ${word.french}">
                        <span class="material-symbols-rounded" aria-hidden="true">volume_up</span>
                    </button>
                `;
                list.appendChild(listItem);
            });

            // Add event listeners for audio buttons
            list.querySelectorAll('.audio-button').forEach(button => {
                button.addEventListener('click', handleAudioPlayback);
            });

            // Add event listener for toggle button
            toggleButton.textContent = 'Hide Translations';
            toggleButton.removeEventListener('click', toggleTranslations); // Remove old listener
            toggleButton.addEventListener('click', toggleTranslations);

            // Set exercise selection set name
            document.getElementById('selected-set-name').textContent = state.selectedSet.name;
        }

        function toggleTranslations() {
            const translations = document.querySelectorAll('#vocabulary-detail-list .translation');
            const toggleButton = document.getElementById('toggle-translation-button');
            const isHidden = translations[0].classList.contains('hidden');

            translations.forEach(span => {
                if (isHidden) {
                    span.classList.remove('hidden');
                } else {
                    span.classList.add('hidden');
                }
            });

            toggleButton.textContent = isHidden ? 'Hide Translations' : 'Show Translations';
            toggleButton.setAttribute('aria-expanded', !isHidden);
        }

        function handleAudioPlayback(event) {
            const button = event.currentTarget;
            const word = button.dataset.word;
            console.log(`Simulating audio playback for: "${word}"`); // Simulate audio

            // Add visual feedback for playback
            button.classList.add('playing');
            button.setAttribute('aria-busy', 'true');

            // Simulate playback duration
            setTimeout(() => {
                 button.classList.remove('playing');
                 button.setAttribute('aria-busy', 'false');
            }, 500); // Animation duration
        }


        function renderExerciseSelection() {
             // Exercise selection view is mostly static HTML, just need to ensure the set name is correct
             document.getElementById('selected-set-name').textContent = state.selectedSet ? state.selectedSet.name : 'a vocabulary set';
             document.getElementById('exercise-selection-title').textContent = state.selectedSet ? `Practice "${state.selectedSet.name}"` : 'Choose an Exercise';

             // Add event listeners to exercise type cards
             document.querySelectorAll('.exercise-type-card').forEach(card => {
                 card.removeEventListener('click', startExercise); // Prevent multiple listeners
                 card.addEventListener('click', startExercise);
                 card.removeEventListener('keypress', handleExerciseCardKeyPress);
                 card.addEventListener('keypress', handleExerciseCardKeyPress);
             });
        }

        function handleExerciseCardKeyPress(event) {
             if (event.key === 'Enter' || event.key === ' ') {
                 startExercise(event);
             }
        }

        function startExercise(event) {
             if (!state.selectedSet) {
                 console.error("No vocabulary set selected for exercise.");
                 // Optionally show a message to the user
                 return;
             }

             state.currentExercise = event.currentTarget.dataset.exercise;
             state.exerciseData = shuffleArray([...state.selectedSet.words]); // Work on a shuffled copy
             state.exerciseIndex = 0;

             // Reset exercise-specific state
             state.matchingPairs = [];
             state.matchingSelected = null;
             state.fillInWord = null;
             state.quizWord = null;
             state.quizOptions = [];
             state.quizCorrectAnswer = null;

             // Render the specific exercise view
             switch (state.currentExercise) {
                 case 'flashcard':
                     renderFlashcard();
                     showView('flashcard-exercise-view');
                     break;
                 case 'matching':
                     renderMatching();
                     showView('matching-exercise-view');
                     break;
                 case 'fill-in-the-blank':
                     renderFillInTheBlank();
                     showView('fill-in-the-blank-exercise-view');
                     break;
                 case 'quiz':
                     renderQuiz();
                     showView('quiz-exercise-view');
                     break;
             }
        }

        // --- Exercise Implementations ---

        function renderFlashcard() {
             const setTitle = document.getElementById('flashcard-set-title');
             const setName = document.getElementById('flashcard-set-name');
             const cardContainer = document.getElementById('flashcard-container');
             const wordSpan = document.getElementById('flashcard-word');
             const translationSpan = document.getElementById('flashcard-translation');
             const audioButton = document.getElementById('flashcard-audio-button');
             const feedbackDiv = document.getElementById('flashcard-feedback');
             const nextButton = document.getElementById('flashcard-next-button');
             const knowButton = document.getElementById('flashcard-know-button');
             const dontKnowButton = document.getElementById('flashcard-dont-know-button');
             const feedbackButtonsDiv = document.querySelector('#flashcard-exercise-view .flashcard-feedback-buttons');
             const flashcardFront = cardContainer.querySelector('.flashcard-front');
             const flashcardBack = cardContainer.querySelector('.flashcard-back');


             setTitle.textContent = 'Flashcards';
             setName.textContent = state.selectedSet.name;

             if (state.exerciseIndex < state.exerciseData.length) {
                 const currentWord = state.exerciseData[state.exerciseIndex];
                 wordSpan.textContent = currentWord.french;
                 translationSpan.textContent = currentWord.english;
                 audioButton.dataset.word = currentWord.french; // Update audio button data
                 audioButton.setAttribute('aria-label', `Play pronunciation for ${currentWord.french}`);

                 cardContainer.classList.remove('flipped'); // Ensure card is not flipped initially
                 feedbackDiv.textContent = '';
                 feedbackDiv.className = 'exercise-feedback'; // Reset classes

                 // Hide feedback buttons initially
                 feedbackButtonsDiv.style.display = 'none';
                 nextButton.style.display = 'none'; // Hide next initially

                 // Update ARIA hidden states
                 flashcardFront.setAttribute('aria-hidden', 'false');
                 flashcardBack.setAttribute('aria-hidden', 'true');


                 // Add flip listener (only once per render cycle)
                 cardContainer.removeEventListener('click', flipFlashcard);
                 cardContainer.addEventListener('click', flipFlashcard);
                 cardContainer.removeEventListener('keypress', handleFlashcardKeyPress);
                 cardContainer.addEventListener('keypress', handleFlashcardKeyPress);


                 // Add feedback button listeners (only once per render cycle)
                 knowButton.removeEventListener('click', handleFlashcardFeedback);
                 knowButton.addEventListener('click', handleFlashcardFeedback);
                 dontKnowButton.removeEventListener('click', handleFlashcardFeedback);
                 dontKnowButton.addEventListener('click', handleFlashcardFeedback);

                 // Add next button listener (only once per render cycle)
                 nextButton.removeEventListener('click', nextFlashcard);
                 nextButton.addEventListener('click', nextFlashcard);

                 // Add audio listener (only once per render cycle)
                 audioButton.removeEventListener('click', handleAudioPlayback);
                 audioButton.addEventListener('click', handleAudioPlayback);


             } else {
                 // Exercise finished
                 const setProgress = state.progress[state.selectedSetId];
                 const knownCount = setProgress ? setProgress.known : 0;
                 const totalWords = state.selectedSet.words.length;

                 feedbackDiv.textContent = `Exercise Complete! You marked ${knownCount} out of ${totalWords} words as Known.`;
                 feedbackDiv.className = 'exercise-feedback success';

                 // Update card content to show completion message
                 cardContainer.innerHTML = `
                     <div class="flashcard-inner">
                         <div class="flashcard-front" style="justify-content: center;">Exercise Complete!</div>
                     </div>
                 `;
                 cardContainer.classList.remove('flipped'); // Ensure it's on the front

                 feedbackButtonsDiv.style.display = 'none';
                 nextButton.style.display = 'block'; // Show next button to go back
                 nextButton.textContent = 'Back to Exercises';
                 nextButton.removeEventListener('click', nextFlashcard); // Remove old listener
                 nextButton.removeEventListener('click', () => showView('exercise-selection-view')); // Prevent adding multiple
                 nextButton.addEventListener('click', () => showView('exercise-selection-view'));

                 // Update set progress (known count already updated by feedback buttons)
                 saveProgress(); // Ensure final progress is saved
             }
        }

        function handleFlashcardKeyPress(event) {
             if (event.key === 'Enter' || event.key === ' ') {
                 flipFlashcard();
             }
        }

        function flipFlashcard() {
             const cardContainer = document.getElementById('flashcard-container');
             const flashcardFront = cardContainer.querySelector('.flashcard-front');
             const flashcardBack = cardContainer.querySelector('.flashcard-back');
             const feedbackButtonsDiv = document.querySelector('#flashcard-exercise-view .flashcard-feedback-buttons');

             cardContainer.classList.add('flipped');

             // Update ARIA hidden states after flip animation
             setTimeout(() => {
                 flashcardFront.setAttribute('aria-hidden', 'true');
                 flashcardBack.setAttribute('aria-hidden', 'false');
                  // Show feedback buttons after a short delay to allow flip animation
                 feedbackButtonsDiv.style.display = 'flex';
                 feedbackButtonsDiv.querySelectorAll('button')[0].focus(); // Focus the first button for keyboard navigation
             }, 300); // Half of transition duration

             cardContainer.removeEventListener('click', flipFlashcard); // Remove listener after flip
             cardContainer.removeEventListener('keypress', handleFlashcardKeyPress);
        }

        function handleFlashcardFeedback(event) {
             const feedbackDiv = document.getElementById('flashcard-feedback');
             const isKnown = event.target.id === 'flashcard-know-button';
             const setProgress = state.progress[state.selectedSetId];
             const currentWordIndex = vocabularyData.find(set => set.id === state.selectedSetId).words.findIndex(word => word.french === state.exerciseData[state.exerciseIndex].french);


             // Ensure progress object exists
             if (!setProgress) {
                 console.error("Progress object not found for set:", state.selectedSetId);
                 return;
             }

             // Simple tracking: increment known/unknown for the set
             // Note: This simple model doesn't prevent double counting if the user
             // sees the same word multiple times in different exercises or sessions.
             // A more robust system would track known/unknown per word ID.
             // For this iteration, we stick to the simpler set-level count based on flashcards.

             if (isKnown) {
                 feedbackDiv.textContent = 'Great!';
                 feedbackDiv.className = 'exercise-feedback success';
                 // Prevent incrementing if already marked known in this session?
                 // For simplicity, just increment.
                 setProgress.known = (setProgress.known || 0) + 1;
             } else {
                 feedbackDiv.textContent = 'Keep practicing!';
                 feedbackDiv.className = 'exercise-feedback error';
                 setProgress.unknown = (setProgress.unknown || 0) + 1;
             }

             // Hide feedback buttons and show next
             document.querySelector('.flashcard-feedback-buttons').style.display = 'none';
             const nextButton = document.getElementById('flashcard-next-button');
             nextButton.style.display = 'block';
             nextButton.focus(); // Focus the next button
             saveProgress(); // Save progress immediately
        }

        function nextFlashcard() {
             state.exerciseIndex++;
             renderFlashcard();
        }


        function renderMatching() {
            const setTitle = document.getElementById('matching-set-title');
            const setName = document.getElementById('matching-set-name');
            const frenchColumn = document.getElementById('matching-french-column');
            const englishColumn = document.getElementById('matching-english-column');
            const checkButton = document.getElementById('matching-check-button');
            const nextButton = document.getElementById('matching-next-button');
            const feedbackDiv = document.getElementById('matching-feedback');
            const canvas = document.getElementById('matching-canvas');
            const container = document.getElementById('matching-columns');
            const ctx = canvas.getContext('2d');

            setTitle.textContent = 'Matching';
            setName.textContent = state.selectedSet.name;
            feedbackDiv.textContent = '';
            feedbackDiv.className = 'exercise-feedback';
            nextButton.disabled = true;
            checkButton.disabled = false;

            frenchColumn.innerHTML = '';
            englishColumn.innerHTML = '';
            state.matchingPairs = [];
            state.matchingSelected = null;

            // Create shuffled lists for matching
            const originalWords = [...state.selectedSet.words]; // Use original order for lookup
            const frenchWords = shuffleArray([...originalWords]);
            const englishWords = shuffleArray([...originalWords]); // Shuffle English translations, keeping word object


            frenchWords.forEach((word, index) => {
                const li = document.createElement('li');
                li.classList.add('matching-item');
                li.dataset.type = 'french';
                li.dataset.frenchWord = word.french; // Store the French word for lookup
                li.setAttribute('role', 'option');
                li.setAttribute('tabindex', '0');
                li.textContent = word.french;
                frenchColumn.appendChild(li);
            });

            englishWords.forEach((word, index) => {
                const li = document.createElement('li');
                li.classList.add('matching-item');
                li.dataset.type = 'english';
                li.dataset.englishWord = word.english; // Store the English word for lookup
                 li.setAttribute('role', 'option');
                 li.setAttribute('tabindex', '0');
                li.textContent = word.english;
                englishColumn.appendChild(li);
            });

            // Set canvas size to match container
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            // Add click and keypress listeners using event delegation on the container
            container.removeEventListener('click', handleMatchingClick);
            container.addEventListener('click', handleMatchingClick);
            container.removeEventListener('keypress', handleMatchingKeyPress);
            container.addEventListener('keypress', handleMatchingKeyPress);


            checkButton.removeEventListener('click', checkMatchingPairs);
            checkButton.addEventListener('click', checkMatchingPairs);

             nextButton.removeEventListener('click', () => showView('exercise-selection-view'));
             nextButton.addEventListener('click', () => showView('exercise-selection-view'));

            // Initial draw (clear canvas)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Redraw lines on window resize
            window.removeEventListener('resize', redrawMatchingLines);
            window.addEventListener('resize', redrawMatchingLines);
        }

        function handleMatchingKeyPress(event) {
             if (event.key === 'Enter' || event.key === ' ') {
                 if (event.target.classList.contains('matching-item')) {
                     handleMatchingClick(event);
                 }
             }
        }


        function handleMatchingClick(event) {
            const clickedItem = event.target.closest('.matching-item'); // Use closest to handle clicks on text inside li
            if (!clickedItem) return;

            const type = clickedItem.dataset.type;

            // Ignore clicks on matched items
            if (clickedItem.classList.contains('matched')) {
                return;
            }

            // Clear any incorrect highlights
            document.querySelectorAll('.matching-item.incorrect').forEach(item => item.classList.remove('incorrect'));
            document.getElementById('matching-feedback').textContent = ''; // Clear feedback on new click
            document.getElementById('matching-feedback').className = 'exercise-feedback';


            if (!state.matchingSelected) {
                // Select the first item
                state.matchingSelected = { type, element: clickedItem };
                clickedItem.classList.add('selected');
                 clickedItem.setAttribute('aria-selected', 'true');
            } else {
                // Select the second item
                const firstItem = state.matchingSelected;
                const secondItem = { type, element: clickedItem };

                // Cannot select two items of the same type
                if (firstItem.type === secondItem.type) {
                    firstItem.element.classList.remove('selected');
                     firstItem.element.removeAttribute('aria-selected');
                    state.matchingSelected = { type, element: clickedItem };
                    clickedItem.classList.add('selected');
                     clickedItem.setAttribute('aria-selected', 'true');
                    return;
                }

                // Store the potential pair
                state.matchingPairs.push([firstItem.element, secondItem.element]);

                // Draw the line immediately
                drawMatchingLine(firstItem.element, secondItem.element, "rgba(var(--primary-color), 0.7)");

                // Clear selection state and UI
                firstItem.element.classList.remove('selected');
                secondItem.element.classList.remove('selected');
                firstItem.element.removeAttribute('aria-selected');
                secondItem.element.removeAttribute('aria-selected');
                state.matchingSelected = null;
            }
        }

        function getElementCenter(element) {
             const rect = element.getBoundingClientRect();
             const containerRect = document.getElementById('matching-columns').getBoundingClientRect();
             return {
                 x: rect.left + rect.width / 2 - containerRect.left,
                 y: rect.top + rect.height / 2 - containerRect.top
             };
        }

        function drawMatchingLine(item1, item2, color) {
            const canvas = document.getElementById('matching-canvas');
            const ctx = canvas.getContext('2d');

            const center1 = getElementCenter(item1);
            const center2 = getElementCenter(item2);

            // Adjust start/end points to be on the edge facing the other column
            const x1 = item1.dataset.type === 'french' ? item1.getBoundingClientRect().right - document.getElementById('matching-columns').getBoundingClientRect().left : center1.x;
            const y1 = center1.y;
            const x2 = item2.dataset.type === 'english' ? item2.getBoundingClientRect().left - document.getElementById('matching-columns').getBoundingClientRect().left : center2.x;
            const y2 = center2.y;


            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function redrawMatchingLines() {
             const canvas = document.getElementById('matching-canvas');
             const container = document.getElementById('matching-columns');
             const ctx = canvas.getContext('2d');

             // Update canvas size
             const rect = container.getBoundingClientRect();
             canvas.width = rect.width;
             canvas.height = rect.height;

             // Clear canvas
             ctx.clearRect(0, 0, canvas.width, canvas.height);

             // Redraw existing matched lines
             state.matchingPairs.forEach(pair => {
                 // Check if elements still exist in the DOM (e.g., after check removed incorrect)
                 if (document.body.contains(pair[0]) && document.body.contains(pair[1])) {
                     // Only redraw lines for items that are currently matched
                     if (pair[0].classList.contains('matched') && pair[1].classList.contains('matched')) {
                          drawMatchingLine(pair[0], pair[1], "var(--success-color)"); // Draw correct lines in green
                     }
                 }
             });
        }


        function checkMatchingPairs() {
            const feedbackDiv = document.getElementById('matching-feedback');
            const checkButton = document.getElementById('matching-check-button');
            const nextButton = document.getElementById('matching-next-button');
            const canvas = document.getElementById('matching-canvas');
            const ctx = canvas.getContext('2d');

            let allAttemptedCorrect = true; // Were all attempted pairs correct?
            let totalMatched = 0;
            const incorrectPairs = [];

            // Clear canvas and redraw correct lines
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            state.matchingPairs.forEach(pair => {
                const item1 = pair[0];
                const item2 = pair[1];

                // Determine which is French and which is English
                const frenchItem = item1.dataset.type === 'french' ? item1 : item2;
                const englishItem = item1.dataset.type === 'english' ? item1 : item2;

                // Find the original word pair in the selected set by French word
                const originalWord = state.selectedSet.words.find(word => word.french === frenchItem.dataset.frenchWord);

                // Check if the English translation matches the original French word's translation
                const isCorrect = originalWord && originalWord.english === englishItem.dataset.englishWord;

                if (isCorrect) {
                    frenchItem.classList.add('matched');
                    englishItem.classList.add('matched');
                    frenchItem.classList.remove('selected', 'incorrect');
                    englishItem.classList.remove('selected', 'incorrect');
                    frenchItem.removeAttribute('aria-selected');
                    englishItem.removeAttribute('aria-selected');
                    frenchItem.setAttribute('aria-disabled', 'true'); // Disable matched items
                    englishItem.setAttribute('aria-disabled', 'true');
                    totalMatched++;
                    drawMatchingLine(frenchItem, englishItem, "var(--success-color)"); // Draw correct lines in green
                } else {
                    frenchItem.classList.add('incorrect');
                    englishItem.classList.add('incorrect');
                    frenchItem.classList.remove('selected');
                    englishItem.classList.remove('selected');
                    frenchItem.removeAttribute('aria-selected');
                    englishItem.removeAttribute('aria-selected');
                    allAttemptedCorrect = false;
                    incorrectPairs.push(pair); // Store incorrect pairs
                }
            });

            // Remove incorrect pairs from state.matchingPairs so user can try again
            state.matchingPairs = state.matchingPairs.filter(pair => {
                 const item1 = pair[0];
                 const item2 = pair[1];
                 const frenchItem = item1.dataset.type === 'french' ? item1 : item2;
                 const englishItem = item1.dataset.type === 'english' ? item1 : item2;
                 const originalWord = state.selectedSet.words.find(word => word.french === frenchItem.dataset.frenchWord);
                 return originalWord && originalWord.english === englishItem.dataset.englishWord;
            });


            const totalWordsInSet = state.selectedSet.words.length;
            const currentlyMatched = document.querySelectorAll('.matching-item.matched').length / 2; // Count matched pairs

            if (currentlyMatched === totalWordsInSet) {
                feedbackDiv.textContent = 'All matches are correct! Exercise Complete!';
                feedbackDiv.className = 'exercise-feedback success';
                checkButton.disabled = true;
                nextButton.disabled = false;
                 // Remove event listeners from container once exercise is done
                 container.removeEventListener('click', handleMatchingClick);
                 container.removeEventListener('keypress', handleMatchingKeyPress);
                 nextButton.focus(); // Focus next button
            } else if (state.matchingPairs.length > 0 || incorrectPairs.length > 0) { // If any pairs were attempted
                 feedbackDiv.textContent = `You have matched ${currentlyMatched} out of ${totalWordsInSet} pairs. Incorrect pairs are highlighted.`;
                 feedbackDiv.className = allAttemptedCorrect ? 'exercise-feedback success' : 'exercise-feedback error';
                 checkButton.disabled = false; // Allow checking again
                 nextButton.disabled = true;
            } else {
                 feedbackDiv.textContent = 'Select items from each column to make a match.';
                 feedbackDiv.className = 'exercise-feedback';
                 checkButton.disabled = false;
                 nextButton.disabled = true;
            }
        }


        function renderFillInTheBlank() {
             const setTitle = document.getElementById('fill-in-set-title');
             const setName = document.getElementById('fill-in-set-name');
             const sentenceDiv = document.getElementById('fill-in-sentence');
             const checkButton = document.getElementById('fill-in-check-button');
             const nextButton = document.getElementById('fill-in-next-button');
             const feedbackDiv = document.getElementById('fill-in-feedback');

             setTitle.textContent = 'Fill in the Blank';
             setName.textContent = state.selectedSet.name;
             feedbackDiv.textContent = '';
             feedbackDiv.className = 'exercise-feedback';
             checkButton.disabled = false;
             nextButton.disabled = true;
             checkButton.style.display = ''; // Show check button
             nextButton.style.display = ''; // Show next button placeholder

             if (state.exerciseIndex < state.exerciseData.length) {
                 const currentWord = state.exerciseData[state.exerciseIndex];
                 state.fillInWord = currentWord;

                 // Create a simple sentence template. Replace the English word with an input.
                 // This is a very basic implementation. A real one would use more complex sentences.
                 // Example: "The English word for [input] is '${currentWord.english}'."
                 const sentenceHtml = `The English word for <input type="text" id="fill-in-input" aria-label="Enter the French word for ${currentWord.english}"> is "${currentWord.english}".`;

                 sentenceDiv.innerHTML = sentenceHtml;
                 state.fillInWord.inputElement = document.getElementById('fill-in-input');


                 // Add event listeners
                 checkButton.removeEventListener('click', checkFillInTheBlank);
                 checkButton.addEventListener('click', checkFillInTheBlank);

                 nextButton.removeEventListener('click', nextFillInTheBlank);
                 nextButton.addEventListener('click', nextFillInTheBlank);

                 // Allow pressing Enter to check
                 state.fillInWord.inputElement.removeEventListener('keypress', handleFillInKeyPress);
                 state.fillInWord.inputElement.addEventListener('keypress', handleFillInKeyPress);

                 state.fillInWord.inputElement.focus(); // Focus the input
             } else {
                 // Exercise finished
                 feedbackDiv.textContent = 'Exercise Complete!';
                 feedbackDiv.className = 'exercise-feedback success';
                 sentenceDiv.innerHTML = 'You have completed this Fill in the Blank exercise.';
                 checkButton.style.display = 'none';
                 nextButton.style.display = 'block';
                 nextButton.textContent = 'Back to Exercises';
                 nextButton.removeEventListener('click', nextFillInTheBlank); // Remove old listener
                 nextButton.removeEventListener('click', () => showView('exercise-selection-view')); // Prevent adding multiple
                 nextButton.addEventListener('click', () => showView('exercise-selection-view'));
                 nextButton.focus();
             }
        }

        function handleFillInKeyPress(event) {
             if (event.key === 'Enter') {
                 event.preventDefault(); // Prevent default form submission if it were a form
                 checkFillInTheBlank();
             }
        }

        function checkFillInTheBlank() {
             const feedbackDiv = document.getElementById('fill-in-feedback');
             const checkButton = document.getElementById('fill-in-check-button');
             const nextButton = document.getElementById('fill-in-next-button');
             const input = state.fillInWord.inputElement;
             const userAnswer = input.value.trim().toLowerCase();
             const correctAnswer = state.fillInWord.french.trim().toLowerCase();

             if (userAnswer === correctAnswer) {
                 feedbackDiv.textContent = 'Correct!';
                 feedbackDiv.className = 'exercise-feedback success';
                 input.classList.add('correct');
                 input.classList.remove('incorrect');
                 input.setAttribute('aria-invalid', 'false');
                 input.disabled = true; // Disable input after correct answer
                 checkButton.disabled = true;
                 nextButton.disabled = false;
                 nextButton.focus(); // Focus next button
             } else {
                 feedbackDiv.textContent = `Incorrect. The correct answer is "${state.fillInWord.french}".`;
                 feedbackDiv.className = 'exercise-feedback error';
                 input.classList.add('incorrect');
                 input.classList.remove('correct');
                 input.setAttribute('aria-invalid', 'true');
                 // Do not disable buttons, allow user to try again or move on
                 checkButton.disabled = false;
                 nextButton.disabled = true;
                 input.focus(); // Keep focus on input to retry
             }
        }

        function nextFillInTheBlank() {
             state.exerciseIndex++;
             renderFillInTheBlank();
        }

        function renderQuiz() {
             const setTitle = document.getElementById('quiz-set-title');
             const setName = document.getElementById('quiz-set-name');
             const questionDiv = document.getElementById('quiz-question');
             const optionsList = document.getElementById('quiz-options');
             const submitButton = document.getElementById('quiz-submit-button');
             const nextButton = document.getElementById('quiz-next-button');
             const feedbackDiv = document.getElementById('quiz-feedback');

             setTitle.textContent = 'Quiz';
             setName.textContent = state.selectedSet.name;
             feedbackDiv.textContent = '';
             feedbackDiv.className = 'exercise-feedback';
             submitButton.disabled = false;
             nextButton.disabled = true;
             optionsList.innerHTML = ''; // Clear previous options
             submitButton.style.display = ''; // Show submit button
             nextButton.style.display = ''; // Show next button placeholder


             if (state.exerciseIndex < state.exerciseData.length) {
                 const currentWord = state.exerciseData[state.exerciseIndex];
                 state.quizWord = currentWord;
                 state.quizCorrectAnswer = currentWord.english; // The English translation is the correct answer

                 // Create question: Ask for the English translation of the French word
                 questionDiv.textContent = `What is the English translation of "${currentWord.french}"?`;

                 // Generate options: Include the correct answer and 3 random incorrect answers
                 const allEnglishTranslations = vocabularyData.flatMap(set => set.words.map(word => word.english));
                 const incorrectOptions = shuffleArray(allEnglishTranslations.filter(trans => trans !== state.quizCorrectAnswer)).slice(0, 3);
                 state.quizOptions = shuffleArray([...incorrectOptions, state.quizCorrectAnswer]);

                 state.quizOptions.forEach((option, index) => {
                     const li = document.createElement('li');
                     const button = document.createElement('button');
                     button.classList.add('quiz-option-button');
                     button.dataset.option = option;
                     button.textContent = option;
                     button.setAttribute('role', 'radio');
                     button.setAttribute('aria-checked', 'false');
                     button.setAttribute('tabindex', '-1'); // Make options focusable but not in tab flow initially
                     if (index === 0) button.setAttribute('tabindex', '0'); // Make first option focusable


                     li.appendChild(button);
                     optionsList.appendChild(li);

                     // Add click listener to option buttons
                     button.removeEventListener('click', handleQuizOptionClick);
                     button.addEventListener('click', handleQuizOptionClick);
                      button.removeEventListener('keypress', handleQuizOptionKeyPress);
                      button.addEventListener('keypress', handleQuizOptionKeyPress);
                 });

                 // Add submit button listener
                 submitButton.removeEventListener('click', checkQuizAnswer);
                 submitButton.addEventListener('click', checkQuizAnswer);

                 // Add next button listener
                 nextButton.removeEventListener('click', nextQuizQuestion);
                 nextButton.addEventListener('click', nextQuizQuestion);

                 // Add keyboard navigation for radio group
                 optionsList.removeEventListener('keydown', handleQuizOptionsKeyboardNav);
                 optionsList.addEventListener('keydown', handleQuizOptionsKeyboardNav);


             } else {
                 // Exercise finished
                 feedbackDiv.textContent = 'Exercise Complete!';
                 feedbackDiv.className = 'exercise-feedback success';
                 questionDiv.textContent = 'You have completed this Quiz exercise.';
                 optionsList.innerHTML = ''; // Clear options
                 submitButton.style.display = 'none';
                 nextButton.style.display = 'block';
                 nextButton.textContent = 'Back to Exercises';
                 nextButton.removeEventListener('click', nextQuizQuestion); // Remove old listener
                 nextButton.removeEventListener('click', () => showView('exercise-selection-view')); // Prevent adding multiple
                 nextButton.addEventListener('click', () => showView('exercise-selection-view'));
                 nextButton.focus();
             }
        }

        function handleQuizOptionsKeyboardNav(event) {
             const options = Array.from(event.target.closest('.quiz-options').querySelectorAll('.quiz-option-button'));
             const currentIndex = options.findIndex(opt => opt === document.activeElement);

             if (event.key === 'ArrowDown' || event.key === 'ArrowRight') {
                 event.preventDefault();
                 const nextIndex = (currentIndex + 1) % options.length;
                 options[nextIndex].focus();
             } else if (event.key === 'ArrowUp' || event.key === 'ArrowLeft') {
                 event.preventDefault();
                 const prevIndex = (currentIndex - 1 + options.length) % options.length;
                 options[prevIndex].focus();
             } else if (event.key === 'Enter' || event.key === ' ') {
                 // Simulate click on focused option
                 if (document.activeElement.classList.contains('quiz-option-button')) {
                     event.preventDefault();
                     handleQuizOptionClick({ target: document.activeElement });
                 }
             }
        }

        function handleQuizOptionKeyPress(event) {
             // This handles the selection when Enter/Space is pressed directly on the button
             if (event.key === 'Enter' || event.key === ' ') {
                 event.preventDefault();
                 handleQuizOptionClick(event);
             }
        }


        function handleQuizOptionClick(event) {
             // Remove 'selected' class from all options
             document.querySelectorAll('#quiz-options .quiz-option-button').forEach(btn => {
                 btn.classList.remove('selected');
                 btn.setAttribute('aria-checked', 'false');
                 btn.setAttribute('tabindex', '-1'); // Remove from tab flow when not selected
             });
             // Add 'selected' class to the clicked option
             const selectedButton = event.target.closest('.quiz-option-button');
             selectedButton.classList.add('selected');
             selectedButton.setAttribute('aria-checked', 'true');
             selectedButton.setAttribute('tabindex', '0'); // Keep selected option in tab flow
             selectedButton.focus(); // Ensure focus is on the selected button


             // Ensure submit button is enabled if an option is selected
             document.getElementById('quiz-submit-button').disabled = false;
        }


        function checkQuizAnswer() {
             const feedbackDiv = document.getElementById('quiz-feedback');
             const submitButton = document.getElementById('quiz-submit-button');
             const nextButton = document.getElementById('quiz-next-button');
             const selectedOptionButton = document.querySelector('#quiz-options .quiz-option-button.selected');

             if (!selectedOptionButton) {
                 feedbackDiv.textContent = 'Please select an answer.';
                 feedbackDiv.className = 'exercise-feedback';
                 return;
             }

             const userAnswer = selectedOptionButton.dataset.option;

             // Disable all option buttons after submission
             document.querySelectorAll('#quiz-options .quiz-option-button').forEach(btn => {
                 btn.disabled = true;
                 // Highlight correct/incorrect
                 if (btn.dataset.option === state.quizCorrectAnswer) {
                     btn.classList.add('correct');
                 } else if (btn.classList.contains('selected')) {
                     btn.classList.add('incorrect');
                 }
             });


             if (userAnswer === state.quizCorrectAnswer) {
                 feedbackDiv.textContent = 'Correct!';
                 feedbackDiv.className = 'exercise-feedback success';
             } else {
                 feedbackDiv.textContent = `Incorrect. The correct answer was "${state.quizCorrectAnswer}".`;
                 feedbackDiv.className = 'exercise-feedback error';
             }

             submitButton.disabled = true;
             nextButton.disabled = false;
             nextButton.focus(); // Focus next button
        }

        function nextQuizQuestion() {
             state.exerciseIndex++;
             renderQuiz();
        }


        // --- Progress View Rendering ---
        function renderProgress() {
            const overallKnownSpan = document.getElementById('overall-known-count');
            const overallTotalSpan = document.getElementById('overall-total-count');
            const overallPercentageSpan = document.getElementById('overall-percentage');
            const progressList = document.getElementById('progress-list');

            progressList.innerHTML = ''; // Clear previous content

            let totalKnownAcrossSets = 0;
            let totalWordsAcrossSets = 0;

            vocabularyData.forEach(set => {
                const setProgress = state.progress[set.id] || { total: set.words.length, known: 0, unknown: 0 };
                const progressPercentage = setProgress.total > 0 ? Math.round((setProgress.known / setProgress.total) * 100) : 0;

                totalKnownAcrossSets += setProgress.known;
                totalWordsAcrossSets += setProgress.total;

                const listItem = document.createElement('li');
                listItem.classList.add('progress-item');
                 listItem.setAttribute('role', 'listitem');
                listItem.innerHTML = `
                    <span>${set.name}</span>
                    <span class="progress-percentage">${progressPercentage}% Known</span>
                `;
                progressList.appendChild(listItem);
            });

            const overallPercentage = totalWordsAcrossSets > 0 ? Math.round((totalKnownAcrossSets / totalWordsAcrossSets) * 100) : 0;

            overallKnownSpan.textContent = totalKnownAcrossSets;
            overallTotalSpan.textContent = totalWordsAcrossSets;
            overallPercentageSpan.textContent = overallPercentage;
        }


        // --- Utility Functions ---
        function shuffleArray(array) {
            const shuffledArray = [...array]; // Create a copy to avoid modifying the original
            for (let i = shuffledArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]]; // Swap elements
            }
            return shuffledArray;
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadProgress(); // Load progress on startup
            renderVocabularyList(); // Render initial list

            // Navigation listeners (using event delegation on header)
            document.querySelector('header nav ul').addEventListener('click', (event) => {
                if (event.target.tagName === 'A') {
                    event.preventDefault();
                    const viewId = event.target.dataset.view + '-view';
                    showView(viewId);

                    // Render specific views if needed
                    if (viewId === 'vocabulary-list-view') {
                        renderVocabularyList();
                    } else if (viewId === 'progress-view') {
                        renderProgress();
                    } else if (viewId === 'exercise-selection-view') {
                         // If navigating directly to exercises, ensure a set is selected or handle appropriately
                         if (!state.selectedSet) {
                              // Redirect to vocabulary list if no set is selected
                              showView('vocabulary-list-view');
                              alert("Please select a vocabulary set first."); // Provide user feedback
                         } else {
                             renderExerciseSelection();
                         }
                    }
                }
            });

             // Listeners for buttons that navigate between views (e.g., on Home or Detail views)
             document.querySelectorAll('[data-navigate]').forEach(button => {
                 button.addEventListener('click', (event) => {
                     const targetView = event.target.dataset.navigate + '-view';
                     showView(targetView);

                      // Render specific views if needed
                     if (targetView === 'vocabulary-list-view') {
                         renderVocabularyList();
                     } else if (targetView === 'exercise-selection-view') {
                          if (!state.selectedSet) {
                              // Redirect to vocabulary list if no set is selected
                              showView('vocabulary-list-view');
                              alert("Please select a vocabulary set first."); // Provide user feedback
                         } else {
                             renderExerciseSelection();
                         }
                     }
                 });
             });


            // Initial view
            showView('home-view');
        });

    </script>
</body>
</html>
