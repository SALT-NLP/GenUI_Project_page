<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Longitudinal Study Data Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <style>
        :root {
            --primary-color: #007bff;
            --primary-color-dark: #0056b3;
            --secondary-color: #6c757d;
            --secondary-color-dark: #545b62;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --background-color: #f8f9fa;
            --surface-color: #ffffff;
            --text-color: #212529;
            --text-light-color: #6c757d;
            --border-color: #dee2e6;
            --spacing-unit: 8px;
            --header-height: 60px;
            --sidebar-width: 300px;
            --card-border-radius: 8px;
            --button-border-radius: 4px;
            --input-border-radius: 4px;
            --shadow-subtle: 0 1px 3px rgba(0, 0, 0, 0.05);
            --shadow-medium: 0 4px 6px rgba(0, 0, 0, 0.1);
            --focus-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            --transition-duration: 0.2s;
            --transition-timing-function: ease-in-out;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-y: auto; /* Allow body to scroll */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        header {
            background-color: var(--surface-color);
            color: var(--text-color);
            padding: 0 calc(var(--spacing-unit) * 3);
            height: var(--header-height);
            display: flex;
            align-items: center;
            box-shadow: var(--shadow-subtle);
            position: sticky;
            top: 0;
            z-index: 100;
            flex-shrink: 0;
        }

        header h1 {
            margin: 0;
            font-size: 1.5em;
            font-weight: 600;
        }

        .layout-container {
            display: grid;
            grid-template-columns: var(--sidebar-width) 1fr;
            flex-grow: 1;
            overflow: hidden; /* Prevent main layout from scrolling */
        }

        aside {
            background-color: var(--surface-color);
            padding: calc(var(--spacing-unit) * 3);
            box-shadow: var(--shadow-subtle);
            overflow-y: auto; /* Allow sidebar content to scroll */
            height: calc(100vh - var(--header-height)); /* Sidebar takes remaining height */
            position: sticky;
            top: var(--header-height);
            flex-shrink: 0;
            border-right: 1px solid var(--border-color);
        }

        main {
            padding: calc(var(--spacing-unit) * 3);
            overflow-y: auto; /* Allow main content to scroll */
            height: calc(100vh - var(--header-height)); /* Main content takes remaining height */
            flex-grow: 1;
        }

        .card {
            background-color: var(--surface-color);
            border-radius: var(--card-border-radius);
            padding: calc(var(--spacing-unit) * 3);
            margin-bottom: calc(var(--spacing-unit) * 4);
            box-shadow: var(--shadow-subtle);
            border: 1px solid var(--border-color);
        }

        .card h2 {
            margin-top: 0;
            margin-bottom: calc(var(--spacing-unit) * 3);
            font-size: 1.25em;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: var(--spacing-unit);
        }

        .card h2 .material-symbols-rounded {
            font-size: 1.5em;
        }

        .form-group {
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        label {
            display: block;
            margin-bottom: var(--spacing-unit);
            font-weight: 500;
            color: var(--text-light-color);
            font-size: 0.9em;
        }

        input[type="text"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: calc(var(--spacing-unit) * 1.5);
            border: 1px solid var(--border-color);
            border-radius: var(--input-border-radius);
            font-size: 1em;
            box-sizing: border-box;
            transition: border-color var(--transition-duration) var(--transition-timing-function), box-shadow var(--transition-duration) var(--transition-timing-function);
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: var(--focus-shadow);
        }

         select:disabled {
             background-color: var(--background-color);
             cursor: not-allowed;
         }


        .checkbox-group,
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-unit);
        }

        .checkbox-group label,
        .radio-group label {
            display: flex;
            align-items: center;
            font-weight: 400;
            font-size: 1em;
            color: var(--text-color);
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"],
        .radio-group input[type="radio"] {
            margin-right: var(--spacing-unit);
            cursor: pointer;
        }

        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 3);
            font-size: 1em;
            font-weight: 500;
            text-align: center;
            text-decoration: none;
            border: 1px solid transparent;
            border-radius: var(--button-border-radius);
            cursor: pointer;
            transition: background-color var(--transition-duration) var(--transition-timing-function), border-color var(--transition-duration) var(--transition-timing-function), color var(--transition-duration) var(--transition-timing-function), opacity var(--transition-duration) var(--transition-timing-function);
            gap: var(--spacing-unit);
        }

        button.primary {
            color: var(--surface-color);
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }

        button.primary:hover {
            background-color: var(--primary-color-dark);
            border-color: var(--primary-color-dark);
        }

        button.secondary {
            color: var(--text-color);
            background-color: var(--secondary-color);
            border-color: var(--secondary-color);
        }

        button.secondary:hover {
            background-color: var(--secondary-color-dark);
            border-color: var(--secondary-color-dark);
            color: var(--surface-color);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .file-upload-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--card-border-radius);
            padding: calc(var(--spacing-unit) * 4);
            text-align: center;
            cursor: pointer;
            transition: border-color var(--transition-duration) var(--transition-timing-function), background-color var(--transition-duration) var(--transition-timing-function);
            margin-bottom: calc(var(--spacing-unit) * 3);
        }

        .file-upload-area.dragover {
            border-color: var(--primary-color);
            background-color: #e9f5ff;
        }

        .file-upload-area p {
            margin: var(--spacing-unit) 0;
            color: var(--text-light-color);
        }

        .file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .file-list li {
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--input-border-radius);
            padding: calc(var(--spacing-unit) * 1.5);
            margin-bottom: var(--spacing-unit);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: calc(var(--spacing-unit) * 4);
            font-size: 0.9em;
        }

        th, td {
            border: 1px solid var(--border-color);
            padding: calc(var(--spacing-unit) * 1.5);
            text-align: left;
        }

        th {
            background-color: var(--background-color);
            font-weight: 600;
            color: var(--text-light-color);
            position: sticky;
            top: 0;
            background-color: var(--background-color); /* Ensure header stays visible on scroll */
            z-index: 10; /* Stay above scrolling body */
        }

        tbody tr:nth-child(even) {
            background-color: var(--background-color);
        }

        .results-table-container {
            max-height: 400px; /* Limit height for scroll */
            overflow-y: auto;
            margin-bottom: calc(var(--spacing-unit) * 4);
            border: 1px solid var(--border-color);
            border-radius: var(--card-border-radius);
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 400px; /* Fixed height for charts */
            margin-bottom: calc(var(--spacing-unit) * 4);
            border: 1px solid var(--border-color);
            border-radius: var(--card-border-radius);
            background-color: var(--surface-color);
            padding: calc(var(--spacing-unit) * 2);
            box-sizing: border-box;
            box-shadow: var(--shadow-subtle);
            overflow: hidden; /* Hide overflowing controls initially */
        }

        .chart-container canvas {
             display: block; /* Remove extra space below canvas */
             width: 100% !important; /* Chart.js override */
             height: 100% !important; /* Chart.js override */
        }

        .floating-controls {
            position: absolute;
            top: calc(var(--spacing-unit) * 2);
            right: calc(var(--spacing-unit) * 2);
            background: rgba(255, 255, 255, 0.95);
            padding: calc(var(--spacing-unit) * 2);
            border-radius: var(--card-border-radius);
            box-shadow: var(--shadow-medium);
            opacity: 0;
            transform: translateY(-10px);
            transition: all var(--transition-duration) var(--transition-timing-function);
            pointer-events: none;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: calc(var(--spacing-unit) * 1.5);
            min-width: 200px;
        }

        .chart-container:hover .floating-controls,
        .floating-controls.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-unit);
        }

        .control-group label {
            font-size: 0.85em;
            font-weight: 500;
            color: var(--text-light-color);
            margin-bottom: 0;
        }

        .control-group input[type="color"],
        .control-group select,
        .control-group input[type="number"] {
             padding: var(--spacing-unit);
             font-size: 0.9em;
             min-height: 38px; /* Ensure clickable area */
        }

        .control-group button {
             width: 100%;
             padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity var(--transition-duration) var(--transition-timing-function), visibility var(--transition-duration) var(--transition-timing-function);
        }

        .modal.visible {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: var(--surface-color);
            padding: calc(var(--spacing-unit) * 4);
            border-radius: var(--card-border-radius);
            box-shadow: var(--shadow-medium);
            max-width: 500px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform var(--transition-duration) var(--transition-timing-function);
        }

        .modal.visible .modal-content {
            transform: translateY(0);
        }

        .modal-content h3 {
            margin-top: 0;
            margin-bottom: calc(var(--spacing-unit) * 3);
            font-size: 1.5em;
            font-weight: 600;
            color: var(--primary-color);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: calc(var(--spacing-unit) * 2);
            margin-top: calc(var(--spacing-unit) * 4);
        }

        .loading-indicator {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        .loading-indicator.visible {
            display: flex;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Icons */
        .material-symbols-rounded {
            font-variation-settings:
            'FILL' 0,
            'wght' 400,
            'GRAD' 0,
            'opsz' 24;
            vertical-align: middle;
        }

        button .material-symbols-rounded {
             font-size: 1.2em;
        }

        /* Custom styles for specific sections */
        #analysis-config .form-group {
            border-bottom: 1px dashed var(--border-color);
            padding-bottom: calc(var(--spacing-unit) * 3);
            margin-bottom: calc(var(--spacing-unit) * 3);
        }
         #analysis-config .form-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .variable-selector select {
            margin-bottom: calc(var(--spacing-unit) * 2);
        }

        .subgroup-selector .checkbox-group {
             margin-top: calc(var(--spacing-unit) * 1.5);
        }

        .analysis-type-selector .radio-group {
             margin-top: calc(var(--spacing-unit) * 1.5);
        }

        /* Export Modal Specifics */
        #export-modal .form-group {
            margin-bottom: calc(var(--spacing-unit) * 2);
        }
        #export-modal label {
            font-size: 1em;
            font-weight: 500;
            color: var(--text-color);
        }
         #export-modal select {
            padding: calc(var(--spacing-unit) * 1.5);
         }

         /* Responsive adjustments */
         @media (max-width: 992px) {
             .layout-container {
                 grid-template-columns: 1fr; /* Stack layout */
             }

             aside {
                 position: static; /* Remove sticky positioning */
                 height: auto; /* Allow height to be determined by content */
                 margin-bottom: calc(var(--spacing-unit) * 4);
                 box-shadow: none; /* Remove sidebar shadow when stacked */
                 border-bottom: 1px solid var(--border-color);
                 border-right: none;
             }

             main {
                 height: auto; /* Allow height to be determined by content */
             }

             header {
                 padding: 0 calc(var(--spacing-unit) * 2);
             }

             aside, main {
                 padding: calc(var(--spacing-unit) * 2);
             }

             .card {
                 padding: calc(var(--spacing-unit) * 2);
             }

             .floating-controls {
                 top: calc(var(--spacing-unit) * 1);
                 right: calc(var(--spacing-unit) * 1);
                 padding: calc(var(--spacing-unit) * 1.5);
                 min-width: 180px;
             }

             .chart-container {
                 height: 350px; /* Adjust chart height */
             }
         }

          @media (max-width: 576px) {
             header h1 {
                 font-size: 1.2em;
             }

              aside, main {
                 padding: calc(var(--spacing-unit) * 1.5);
             }

             .card {
                 padding: calc(var(--spacing-unit) * 1.5);
                 margin-bottom: calc(var(--spacing-unit) * 3);
             }

             .card h2 {
                 font-size: 1.1em;
                 margin-bottom: calc(var(--spacing-unit) * 2);
             }

             .form-group {
                 margin-bottom: calc(var(--spacing-unit) * 2);
             }

             label {
                 margin-bottom: calc(var(--spacing-unit) * 0.5);
                 font-size: 0.85em;
             }

             input[type="text"],
             input[type="number"],
             select,
             textarea {
                 padding: var(--spacing-unit);
                 font-size: 0.9em;
             }

             button {
                 padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
                 font-size: 0.9em;
             }

             .file-upload-area {
                 padding: calc(var(--spacing-unit) * 2);
             }

             .file-upload-area p {
                 font-size: 0.9em;
             }

             .file-list li {
                 padding: var(--spacing-unit);
                 font-size: 0.8em;
             }

             th, td {
                 padding: var(--spacing-unit);
             }

             .results-table-container {
                 max-height: 300px;
             }

             .chart-container {
                 height: 300px;
                 padding: var(--spacing-unit);
             }

             .floating-controls {
                 top: var(--spacing-unit);
                 right: var(--spacing-unit);
                 padding: var(--spacing-unit);
                 min-width: 150px;
                 font-size: 0.9em;
             }

             .control-group {
                 gap: calc(var(--spacing-unit) * 0.5);
             }

             .control-group label {
                 font-size: 0.8em;
             }

             .modal-content {
                 padding: calc(var(--spacing-unit) * 3);
             }

             .modal-content h3 {
                 font-size: 1.3em;
                 margin-bottom: calc(var(--spacing-unit) * 2);
             }

             .modal-actions {
                 margin-top: calc(var(--spacing-unit) * 3);
                 gap: var(--spacing-unit);
             }
          }
    </style>
</head>
<body>

    <header>
        <h1>Longitudinal Study Analysis Platform</h1>
    </header>

    <div class="layout-container">
        <aside>
            <div id="data-upload" class="card" aria-labelledby="data-upload-heading">
                <h2 id="data-upload-heading"><span class="material-symbols-rounded">upload_file</span> Data Upload</h2>
                <div class="file-upload-area" id="drop-area" role="group" aria-label="File Upload Area">
                    <input type="file" id="file-input" multiple accept=".csv, .json" style="display: none;" aria-describedby="file-upload-help">
                    <p>Drag & drop your data files here, or <a href="#" onclick="document.getElementById('file-input').click(); return false;" aria-label="Browse files">browse</a></p>
                    <p id="file-upload-help"><small>(.csv, .json supported)</small></p>
                </div>
                <ul id="file-list" class="file-list" aria-live="polite" aria-atomic="true">
                    <!-- Uploaded files will be listed here -->
                </ul>
                <button id="process-data-btn" class="primary" style="width: 100%; margin-top: calc(var(--spacing-unit)*2);" disabled aria-label="Process Uploaded Data">
                     <span class="material-symbols-rounded">settings</span> Process Data
                </button>
            </div>

            <div id="analysis-config" class="card" aria-labelledby="analysis-config-heading">
                <h2 id="analysis-config-heading"><span class="material-symbols-rounded">analytics</span> Analysis Configuration</h2>
                 <div class="form-group variable-selector">
                    <label for="dependent-var">Dependent Variable:</label>
                    <select id="dependent-var" disabled aria-required="true">
                        <option value="">Select variable</option>
                        <!-- Options populated from data -->
                    </select>
                </div>

                <div class="form-group variable-selector">
                    <label for="independent-var">Independent Variable (Intervention):</label>
                    <select id="independent-var" disabled aria-required="true">
                        <option value="">Select variable</option>
                        <!-- Options populated from data -->
                    </select>
                </div>

                 <div class="form-group variable-selector">
                    <label for="time-var">Time Variable:</label>
                    <select id="time-var" disabled aria-required="true">
                        <option value="">Select variable</option>
                        <!-- Options populated from data -->
                    </select>
                </div>

                <div class="form-group variable-selector">
                    <label for="confounding-vars">Confounding Variables (Select multiple):</label>
                    <select id="confounding-vars" multiple disabled aria-label="Select confounding variables">
                        <!-- Options populated from data -->
                    </select>
                </div>

                <div class="form-group subgroup-selector" role="group" aria-labelledby="subgroup-label">
                    <label id="subgroup-label">Subgroup Analysis:</label>
                    <div id="subgroup-options" class="checkbox-group">
                        <!-- Subgroup options populated from data -->
                        <label><input type="checkbox" value="all" disabled> All Students</label>
                    </div>
                </div>

                <div class="form-group analysis-type-selector" role="radiogroup" aria-labelledby="analysis-type-label">
                    <label id="analysis-type-label">Analysis Type:</label>
                     <div id="analysis-type-options" class="radio-group">
                        <label><input type="radio" name="analysisType" value="regression" disabled> Longitudinal Regression</label>
                        <label><input type="radio" name="analysisType" value="anova" disabled> Repeated Measures ANOVA</label>
                        <label><input type="radio" name="mixed" disabled> Mixed-Effects Model</label>
                    </div>
                </div>

                <button id="run-analysis-btn" class="primary" style="width: 100%;" disabled aria-label="Run Analysis">
                    <span class="material-symbols-rounded">play_arrow</span> Run Analysis
                </button>
            </div>

             <div id="visualization-controls" class="card" aria-labelledby="visualization-controls-heading">
                <h2 id="visualization-controls-heading"><span class="material-symbols-rounded">bar_chart</span> Visualization Controls</h2>
                 <div class="form-group">
                    <label for="chart-type-selector">Generate Chart Type:</label>
                    <select id="chart-type-selector" disabled aria-required="true">
                        <option value="">Select chart type</option>
                        <option value="line">Line Chart (Trends)</option>
                        <option value="bar">Bar Chart (Comparisons)</option>
                        <option value="scatter">Scatter Plot (Relationships)</option>
                        <option value="box">Box Plot (Distributions)</option>
                    </select>
                </div>
                <button id="generate-chart-btn" class="secondary" style="width: 100%;" disabled aria-label="Generate Chart">
                     <span class="material-symbols-rounded">add_chart</span> Generate Chart
                </button>
            </div>

             <div id="export-section" class="card" aria-labelledby="export-section-heading">
                <h2 id="export-section-heading"><span class="material-symbols-rounded">download</span> Export</h2>
                 <button id="open-export-modal-btn" class="secondary" style="width: 100%;" disabled aria-label="Open Export Options">
                     <span class="material-symbols-rounded">download</span> Export Results/Charts
                </button>
            </div>
        </aside>

        <main>
            <div id="data-preview-area" class="card" style="display: none;" aria-labelledby="data-preview-heading">
                <h2 id="data-preview-heading"><span class="material-symbols-rounded">table</span> Data Preview</h2>
                <div style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: var(--card-border-radius);">
                    <table id="data-preview-table" role="grid">
                        <thead>
                            <tr><!-- Headers populated from data --></tr>
                        </thead>
                        <tbody>
                            <!-- Data rows populated from data -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="analysis-results-area" class="card" style="display: none;" aria-labelledby="analysis-results-heading">
                <h2 id="analysis-results-heading"><span class="material-symbols-rounded">list_alt</span> Analysis Results</h2>
                 <div id="results-content" aria-live="polite">
                    <!-- Analysis results tables will be added here -->
                 </div>
            </div>

            <div id="chart-display-area" class="card" style="display: none;" aria-labelledby="chart-display-heading">
                <h2 id="chart-display-heading"><span class="material-symbols-rounded">insights</span> Data Visualizations</h2>
                <div id="charts-container" aria-live="polite">
                    <!-- Charts will be dynamically added here -->
                </div>
            </div>
        </main>
    </div>

    <!-- Export Modal -->
    <div id="export-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="export-modal-heading">
        <div class="modal-content">
            <h3 id="export-modal-heading">Export Options</h3>
            <div class="form-group">
                <label for="export-format">Select Format:</label>
                <select id="export-format">
                    <option value="csv">CSV (Data/Results)</option>
                    <option value="json">JSON (Data/Results)</option>
                    <option value="png">PNG (Charts)</option>
                    <!-- SVG export is complex for Chart.js without plugins -->
                    <!-- <option value="svg">SVG (Charts - if supported)</option> -->
                </select>
            </div>
             <div class="form-group">
                <label for="export-content">Select Content:</label>
                <select id="export-content">
                    <option value="data">Processed Data</option>
                    <option value="results">Analysis Results</option>
                    <option value="all-charts">All Charts</option>
                    <!-- Specific chart options added dynamically -->
                </select>
            </div>
            <div class="modal-actions">
                <button class="secondary" onclick="closeModal('export-modal')" aria-label="Cancel Export">Cancel</button>
                <button id="export-confirm-btn" class="primary" aria-label="Confirm Export">Export</button>
            </div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading-indicator" class="loading-indicator" role="status" aria-live="assertive" aria-label="Loading...">
        <div class="spinner"></div>
    </div>

    <script type="module">
        import { Chart } from "https://esm.sh/chart.js/auto";
        // Import Chart.js Box Plot plugin if needed and available via ESM
        // import 'https://esm.sh/chartjs-chart-box-and-violin-plot'; // Example, verify availability

        // --- State Management ---
        let appState = {
            uploadedFiles: [],
            processedData: null,
            analysisResults: null,
            charts: [], // Array of { id, chartInstance, config }
            chartCounter: 0,
            availableVariables: [],
            availableSubgroups: [],
            selectedConfig: {
                dependentVar: '',
                independentVar: '',
                timeVar: '',
                confoundingVars: [],
                subgroups: [], // Stores variable names of selected subgroup types
                analysisType: ''
            }
        };

        // --- DOM Elements ---
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const fileList = document.getElementById('file-list');
        const processDataBtn = document.getElementById('process-data-btn');

        const dataPreviewArea = document.getElementById('data-preview-area');
        const dataPreviewTable = document.getElementById('data-preview-table');

        const dependentVarSelect = document.getElementById('dependent-var');
        const independentVarSelect = document.getElementById('independent-var');
        const timeVarSelect = document.getElementById('time-var');
        const confoundingVarsSelect = document.getElementById('confounding-vars');
        const subgroupOptionsDiv = document.getElementById('subgroup-options');
        const analysisTypeOptionsDiv = document.getElementById('analysis-type-options');
        const runAnalysisBtn = document.getElementById('run-analysis-btn');

        const analysisResultsArea = document.getElementById('analysis-results-area');
        const resultsContentDiv = document.getElementById('results-content');

        const chartTypeSelector = document.getElementById('chart-type-selector');
        const generateChartBtn = document.getElementById('generate-chart-btn');
        const chartsContainer = document.getElementById('charts-container');
        const chartDisplayArea = document.getElementById('chart-display-area');

        const exportModal = document.getElementById('export-modal');
        const openExportModalBtn = document.getElementById('open-export-modal-btn');
        const exportFormatSelect = document.getElementById('export-format');
        const exportContentSelect = document.getElementById('export-content');
        const exportConfirmBtn = document.getElementById('export-confirm-btn');

        const loadingIndicator = document.getElementById('loading-indicator');

        // --- Utility Functions ---
        function showLoading() { loadingIndicator.classList.add('visible'); }
        function hideLoading() { loadingIndicator.classList.remove('visible'); }

        function showModal(id) { document.getElementById(id).classList.add('visible'); }
        function closeModal(id) { document.getElementById(id).classList.remove('visible'); }

        function enableElement(el) { el.disabled = false; }
        function disableElement(el) { el.disabled = true; }

        function populateSelect(selectElement, options, valueKey, textKey, addDefault = true) {
            selectElement.innerHTML = '';
            if (addDefault) {
                 selectElement.innerHTML += '<option value="">Select variable</option>';
            }
            options.forEach(item => {
                const option = document.createElement('option');
                option.value = item[valueKey];
                option.textContent = item[textKey];
                selectElement.appendChild(option);
            });
        }

        function populateCheckboxes(container, options, valueKey, textKey) {
            container.innerHTML = ''; // Clear existing
             options.forEach(item => {
                const label = document.createElement('label');
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.value = item[valueKey];
                input.setAttribute('aria-label', `Include ${item[textKey]} subgroup`); // ARIA label
                label.appendChild(input);
                label.appendChild(document.createTextNode(item[textKey]));
                container.appendChild(label);
            });
             // Add default "All Students" option
             const allLabel = document.createElement('label');
             const allInput = document.createElement('input');
             allInput.type = 'checkbox';
             allInput.value = 'all';
             allInput.setAttribute('aria-label', 'Include all students subgroup');
             allLabel.appendChild(allInput);
             allLabel.appendChild(document.createTextNode('All Students'));
             container.appendChild(allLabel);
        }

         function populateRadioButtons(container, name, options, valueKey, textKey) {
            container.innerHTML = ''; // Clear existing
             options.forEach(item => {
                const label = document.createElement('label');
                const input = document.createElement('input');
                input.type = 'radio';
                input.name = name;
                input.value = item[valueKey];
                 input.setAttribute('aria-label', `Select ${item[textKey]} analysis type`); // ARIA label
                label.appendChild(input);
                label.appendChild(document.createTextNode(item[textKey]));
                container.appendChild(label);
            });
        }


        // --- Data Handling ---
        function handleFiles(files) {
            appState.uploadedFiles = Array.from(files);
            renderFileList();
            if (appState.uploadedFiles.length > 0) {
                enableElement(processDataBtn);
            } else {
                disableElement(processDataBtn);
            }
        }

        function renderFileList() {
            fileList.innerHTML = '';
            if (appState.uploadedFiles.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No files selected.';
                 li.setAttribute('aria-live', 'off'); // Not a dynamic update
                fileList.appendChild(li);
            } else {
                appState.uploadedFiles.forEach(file => {
                    const li = document.createElement('li');
                    li.textContent = `${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
                    li.setAttribute('aria-live', 'polite'); // Announce new files
                    fileList.appendChild(li);
                });
            }
        }

        async function processData() {
            if (appState.uploadedFiles.length === 0) {
                alert('Please upload data files first.');
                return;
            }

            showLoading();
            // Simulate data processing (parsing, merging if multiple files, basic cleaning)
            await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate delay

            // --- Placeholder Data Generation ---
            // In a real app, this would parse uploaded files (CSV, JSON)
            // and structure the data appropriately for analysis.
            // This placeholder creates a dummy dataset.
            const dummyData = [];
            const students = 150; // Increased students for more data points
            const timepoints = 5; // Increased timepoints (0, 1, 2, 3, 4)
            const interventions = ['Control', 'Intervention A', 'Intervention B'];
            const subgroups = ['First-Gen', 'Low Income', 'URM']; // Subgroup variables
            const baseGPA = 2.8;
            const baseBelonging = 6;
            const baseStress = 7;
            const baseStudyHours = 12;


            for (let i = 1; i <= students; i++) {
                const studentId = `Student_${i}`;
                const intervention = interventions[Math.floor(Math.random() * interventions.length)];

                // Assign subgroup status consistently for each student
                const isFirstGen = Math.random() > 0.4; // ~60% First-Gen
                const isLowIncome = Math.random() > 0.5; // ~50% Low Income
                const isURM = Math.random() > 0.6; // ~40% URM


                for (let t = 0; t < timepoints; t++) { // Timepoints 0, 1, 2, 3, 4
                    const timeValue = t; // Numeric timepoint

                    // Simulate effects and noise
                    let gpa = baseGPA
                                + (t * 0.1) // General trend upward
                                + (intervention === 'Intervention A' ? t * 0.15 : (intervention === 'Intervention B' ? t * 0.07 : 0)) // Intervention effect over time
                                + (isFirstGen ? -0.15 : 0) // Baseline difference for FirstGen
                                + (isLowIncome ? -0.08 : 0) // Baseline difference for LowIncome
                                + (isURM ? -0.1 : 0) // Baseline difference for URM
                                + (Math.random() - 0.5) * 0.3; // Random noise

                    let belonging = baseBelonging
                                + (t * 0.3)
                                + (intervention === 'Intervention A' ? t * 0.4 : (intervention === 'Intervention B' ? t * 0.15 : 0))
                                + (isFirstGen ? -0.6 : 0)
                                + (Math.random() - 0.5) * 0.7;

                    let stress = baseStress
                                - (t * 0.2)
                                - (intervention === 'Intervention A' ? t * 0.3 : (intervention === 'Intervention B' ? t * 0.1 : 0))
                                + (isLowIncome ? 0.4 : 0)
                                + (Math.random() - 0.5) * 1;

                     let studyHours = baseStudyHours
                                 + (t * 0.5)
                                 + (intervention === 'Intervention A' ? t * 0.8 : (intervention === 'Intervention B' ? t * 0.3 : 0))
                                 + (Math.random() - 0.5) * 1.5;


                    dummyData.push({
                        StudentID: studentId,
                        Intervention: intervention,
                        Timepoint: timeValue, // Use numeric timepoint
                        GPA: Math.max(1.0, Math.min(4.0, parseFloat(gpa.toFixed(2)))),
                        Belonging: Math.max(1, Math.min(10, parseFloat(belonging.toFixed(1)))),
                        Stress: Math.max(1, Math.min(10, parseFloat(stress.toFixed(1)))),
                        StudyHours: Math.max(0, parseFloat(studyHours.toFixed(1))),
                        FirstGen: isFirstGen ? 'Yes' : 'No',
                        LowIncome: isLowIncome ? 'Yes' : 'No',
                        URM: isURM ? 'Yes' : 'No'
                    });
                }
            }

            appState.processedData = dummyData;

            // Extract variables and subgroups from processed data
            if (appState.processedData.length > 0) {
                const firstRow = appState.processedData[0];
                // Exclude StudentID as a standard variable option for analysis/plotting
                appState.availableVariables = Object.keys(firstRow)
                    .filter(key => key !== 'StudentID')
                    .map(key => ({ value: key, text: key }));

                // Identify potential subgroup variables (e.g., categorical with limited unique values)
                // Exclude StudentID and Timepoint as subgroup variables
                const potentialSubgroupVars = Object.keys(firstRow).filter(key => {
                    if (key === 'StudentID' || key === 'Timepoint') return false;
                    const uniqueValues = new Set(appState.processedData.map(d => d[key]));
                    return uniqueValues.size > 1 && uniqueValues.size <= 10; // Heuristic for categorical
                });
                 appState.availableSubgroups = potentialSubgroupVars.map(key => ({ value: key, text: key }));


                // Populate dropdowns and checkboxes
                populateSelect(dependentVarSelect, appState.availableVariables, 'value', 'text');
                populateSelect(independentVarSelect, appState.availableVariables, 'value', 'text');
                populateSelect(timeVarSelect, appState.availableVariables, 'value', 'text');
                populateSelect(confoundingVarsSelect, appState.availableVariables, 'value', 'text', false); // No default "Select variable" for multi-select
                populateCheckboxes(subgroupOptionsDiv, appState.availableSubgroups, 'value', 'text');
                populateRadioButtons(analysisTypeOptionsDiv, 'analysisType', [
                    { value: 'regression', text: 'Longitudinal Regression' },
                    { value: 'anova', text: 'Repeated Measures ANOVA' },
                    { value: 'mixed', text: 'Mixed-Effects Model' }
                ], 'value', 'text');


                // Enable config controls
                enableElement(dependentVarSelect);
                enableElement(independentVarSelect);
                enableElement(timeVarSelect);
                enableElement(confoundingVarsSelect);
                subgroupOptionsDiv.querySelectorAll('input').forEach(enableElement);
                analysisTypeOptionsDiv.querySelectorAll('input').forEach(enableElement);
                 enableElement(chartTypeSelector);
                enableElement(generateChartBtn);
                enableElement(openExportModalBtn);


                // Show data preview
                renderDataPreview(appState.processedData);
                dataPreviewArea.style.display = 'block';
            } else {
                 // Disable config controls if no data
                disableElement(dependentVarSelect);
                disableElement(independentVarSelect);
                disableElement(timeVarSelect);
                disableElement(confoundingVarsSelect);
                subgroupOptionsDiv.querySelectorAll('input').forEach(disableElement);
                analysisTypeOptionsDiv.querySelectorAll('input').forEach(disableElement);
                disableElement(runAnalysisBtn);
                disableElement(chartTypeSelector);
                disableElement(generateChartBtn);
                disableElement(openExportModalBtn);
                dataPreviewArea.style.display = 'none';
            }

            // Update analysis config state and button state
            updateSelectedConfig();

            hideLoading();
        }

        function renderDataPreview(data) {
            if (!data || data.length === 0) {
                dataPreviewTable.innerHTML = '';
                return;
            }

            const headerRow = document.createElement('tr');
            Object.keys(data[0]).forEach(key => {
                const th = document.createElement('th');
                th.textContent = key;
                th.setAttribute('scope', 'col'); // ARIA scope
                headerRow.appendChild(th);
            });
            dataPreviewTable.innerHTML = ''; // Clear previous content
            dataPreviewTable.appendChild(document.createElement('thead')).appendChild(headerRow);

            const tbody = document.createElement('tbody');
            // Display only first 50 rows for preview to avoid performance issues with large datasets
            data.slice(0, 50).forEach(row => {
                const tr = document.createElement('tr');
                Object.values(row).forEach((value, index) => {
                    const td = document.createElement('td');
                    td.textContent = value;
                     if (index === 0) { // Assuming first column is ID
                         td.setAttribute('scope', 'row'); // ARIA scope
                     }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            dataPreviewTable.appendChild(tbody);
        }


        // --- Analysis ---
        function updateSelectedConfig() {
            appState.selectedConfig.dependentVar = dependentVarSelect.value;
            appState.selectedConfig.independentVar = independentVarSelect.value;
            appState.selectedConfig.timeVar = timeVarSelect.value;
            appState.selectedConfig.confoundingVars = Array.from(confoundingVarsSelect.selectedOptions).map(option => option.value);
            appState.selectedConfig.subgroups = Array.from(subgroupOptionsDiv.querySelectorAll('input[type="checkbox"]:checked')).map(input => input.value).filter(v => v !== 'all'); // Exclude 'all' from selected subgroups list
            const selectedAnalysisType = analysisTypeOptionsDiv.querySelector('input[name="analysisType"]:checked');
            appState.selectedConfig.analysisType = selectedAnalysisType ? selectedAnalysisType.value : '';

            // Enable/Disable Run Analysis button based on config completeness
            // Requires Dependent, Independent, Time, and Analysis Type to be selected, and data processed.
            const isConfigComplete = appState.selectedConfig.dependentVar !== '' &&
                                     appState.selectedConfig.independentVar !== '' &&
                                     appState.selectedConfig.timeVar !== '' &&
                                     appState.selectedConfig.analysisType !== '' &&
                                     appState.processedData !== null &&
                                     appState.processedData.length > 0;


            if (isConfigComplete) {
                enableElement(runAnalysisBtn);
            } else {
                disableElement(runAnalysisBtn);
            }
        }

        async function runAnalysis() {
            const config = appState.selectedConfig;
             if (!config.dependentVar || !config.independentVar || !config.timeVar || !config.analysisType) {
                 alert('Please complete the required analysis configuration fields.');
                 return;
             }

            showLoading();
            // Simulate analysis based on selected config
            await new Promise(resolve => setTimeout(resolve, 2500)); // Simulate longer delay for analysis

            // --- Placeholder Analysis Results ---
            // This generates dummy results that mimic statistical output.
            const results = {
                type: config.analysisType,
                dependentVariable: config.dependentVar,
                independentVariable: config.independentVar,
                timeVariable: config.timeVar,
                confoundingVariables: config.confoundingVars,
                subgroupsAnalyzed: config.subgroups.length > 0 ? config.subgroups : ['All Students'],
                tables: []
            };

            // Function to generate plausible dummy stats
            const generateDummyStats = (baseP = 0.1) => ({
                coefficient: (Math.random() * 0.5 - 0.25).toFixed(3), // Range -0.25 to +0.25
                stdError: (Math.random() * 0.1 + 0.05).toFixed(3), // Range 0.05 to 0.15
                pValue: (Math.random() * baseP).toFixed(3) // Range 0 to baseP
            });

            // Main Effects Table
            const mainEffectsRows = [];
            mainEffectsRows.push(['(Intercept)', (Math.random() * 5).toFixed(3), (Math.random() * 0.5).toFixed(3), (Math.random() * 10).toFixed(2), (Math.random() * 0.001).toFixed(3)]); // Intercept is usually significant

            // Simulate effect for Independent Variable (Intervention)
            const indepStats = generateDummyStats(0.05); // Often significant
            mainEffectsRows.push([config.independentVar, indepStats.coefficient, indepStats.stdError, (parseFloat(indepStats.coefficient) / parseFloat(indepStats.stdError)).toFixed(2), indepStats.pValue]);

            // Simulate effect for Time Variable
             const timeStats = generateDummyStats(0.01); // Often significant in longitudinal studies
             mainEffectsRows.push([config.timeVar, timeStats.coefficient, timeStats.stdError, (parseFloat(timeStats.coefficient) / parseFloat(timeStats.stdError)).toFixed(2), timeStats.pValue]);


            // Simulate effects for Confounding Variables
            config.confoundingVars.forEach(v => {
                 const confoundStats = generateDummyStats(0.2); // Can be significant or not
                 mainEffectsRows.push([v, confoundStats.coefficient, confoundStats.stdError, (parseFloat(confoundStats.coefficient) / parseFloat(confoundStats.stdError)).toFixed(2), confoundStats.pValue]);
            });

             // Add main effects table
            results.tables.push({
                title: `Main Effects Model: ${config.analysisType.toUpperCase()} on ${config.dependentVar}`,
                headers: ['Term', 'Coefficient', 'Std. Error', 'T-value', 'P-value'],
                rows: mainEffectsRows
            });


             // Dummy table for subgroup interactions (if subgroups selected)
            if (config.subgroups.length > 0) {
                 config.subgroups.forEach(subgroupVar => {
                     // Simulate interactions for each level of the subgroup variable found in data
                     // Assuming binary subgroups ('Yes'/'No') for simplicity
                     const uniqueSubgroupValues = ['Yes', 'No']; // Simplified assumption

                     uniqueSubgroupValues.forEach(subgroupValue => {
                          if (subgroupValue === 'No') return; // Only show interaction for the 'Yes' level

                          const interactionRows = [];

                          // Simulate interaction term for independent variable * subgroup variable level
                          const interactionStats = generateDummyStats(0.15); // Interaction can be significant or not
                          interactionRows.push([`${config.independentVar} x ${subgroupVar} (${subgroupValue})`, interactionStats.coefficient, interactionStats.stdError, (parseFloat(interactionStats.coefficient) / parseFloat(interactionStats.stdError)).toFixed(2), interactionStats.pValue]);

                           // Optionally add main effects again in interaction model table for comparison
                           // This is common in regression output
                           interactionRows.push(...mainEffectsRows);


                          results.tables.push({
                            title: `Interaction Model: ${config.independentVar} * ${subgroupVar} (${subgroupValue}) on ${config.dependentVar}`,
                            headers: ['Term', 'Coefficient', 'Std. Error', 'T-value', 'P-value'],
                            rows: interactionRows
                        });
                     });
                 });
            }


            appState.analysisResults = results;
            renderAnalysisResults(results);
            analysisResultsArea.style.display = 'block';

            hideLoading();
        }

        function renderAnalysisResults(results) {
            resultsContentDiv.innerHTML = ''; // Clear previous results

            if (!results || results.tables.length === 0) {
                resultsContentDiv.innerHTML = '<p>No analysis results available.</p>';
                return;
            }

            results.tables.forEach(tableData => {
                const tableTitle = document.createElement('h3');
                tableTitle.textContent = tableData.title;
                tableTitle.style.marginTop = `calc(${getComputedStyle(document.documentElement).getPropertyValue('--spacing-unit')} * 4)`;
                tableTitle.style.marginBottom = `calc(${getComputedStyle(document.documentElement).getPropertyValue('--spacing-unit')} * 2)`;
                tableTitle.style.fontSize = '1.1em';
                tableTitle.style.color = getComputedStyle(document.documentElement).getPropertyValue('--text-color');
                resultsContentDiv.appendChild(tableTitle);

                const tableContainer = document.createElement('div');
                tableContainer.classList.add('results-table-container');

                const table = document.createElement('table');
                table.setAttribute('role', 'grid'); // ARIA role for tables
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                const headerRow = document.createElement('tr');
                tableData.headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    th.setAttribute('scope', 'col'); // ARIA scope for headers
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);

                tableData.rows.forEach(rowData => {
                    const tr = document.createElement('tr');
                    rowData.forEach((cellData, index) => {
                        const td = document.createElement('td');
                        td.textContent = cellData;
                         if (index === 0) { // First column is the term/variable
                             td.setAttribute('scope', 'row'); // ARIA scope for row headers
                         }
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });

                table.appendChild(thead);
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                resultsContentDiv.appendChild(tableContainer);
            });
        }


        // --- Visualization ---
        function generateChart() {
             const chartType = chartTypeSelector.value;
             const config = appState.selectedConfig;

             if (!chartType || !config.dependentVar || !config.independentVar || !config.timeVar || !appState.processedData) {
                 alert('Please select a chart type and ensure required analysis configuration variables are selected.');
                 return;
             }

             showLoading();
             // Simulate data preparation for chart
             setTimeout(() => { // Use timeout to simulate async data prep
                 const chartId = `chart-${appState.chartCounter++}`;
                 const chartContainer = document.createElement('div');
                 chartContainer.classList.add('chart-container');
                 chartContainer.setAttribute('data-chart-id', chartId);
                 chartContainer.setAttribute('role', 'img'); // ARIA role for chart
                 chartContainer.setAttribute('aria-label', `Data visualization: ${chartType} of ${config.dependentVar} by ${config.independentVar} over ${config.timeVar}`);


                 const canvas = document.createElement('canvas');
                 canvas.id = chartId;
                 chartContainer.appendChild(canvas);

                 const controls = document.createElement('div');
                 controls.classList.add('floating-controls');
                 controls.id = `controls-${chartId}`;
                 controls.setAttribute('aria-expanded', 'false');
                 controls.setAttribute('aria-controls', chartId);


                 controls.innerHTML = `
                    <button class="secondary" id="toggle-controls-${chartId}" aria-label="Toggle chart controls">
                         <span class="material-symbols-rounded">settings</span>
                    </button>
                    <div class="control-panel-content" style="display: none;">
                        <div class="control-group">
                            <label for="chartType-${chartId}">Chart Type</label>
                            <select id="chartType-${chartId}" aria-label="Change chart type">
                                <option value="line" ${chartType === 'line' ? 'selected' : ''}>Line</option>
                                <option value="bar" ${chartType === 'bar' ? 'selected' : ''}>Bar</option>
                                <option value="scatter" ${chartType === 'scatter' ? 'selected' : ''}>Scatter</option>
                                <option value="box" ${chartType === 'box' ? 'selected' : ''}>Box Plot (Simulated)</option>
                            </select>
                        </div>
                         <div class="control-group">
                            <label for="color-${chartId}">Base Color</label>
                            <input type="color" id="color-${chartId}" value="#007bff" aria-label="Change chart base color">
                        </div>
                        <div class="control-group">
                            <label for="filter-subgroup-${chartId}">Filter Subgroup</label>
                            <select id="filter-subgroup-${chartId}" aria-label="Filter chart by subgroup">
                                 <option value="all">All Students</option>
                                 ${appState.availableSubgroups.map(sub => `<option value="${sub.value}">${sub.text}</option>`).join('')}
                            </select>
                        </div>
                        <div class="control-group">
                            <button class="secondary" id="export-chart-${chartId}" aria-label="Export this chart as PNG">
                                <span class="material-symbols-rounded">download</span> Export PNG
                            </button>
                        </div>
                    </div>
                 `;
                 chartContainer.appendChild(controls);

                 chartsContainer.appendChild(chartContainer);
                 chartDisplayArea.style.display = 'block';

                 // --- Placeholder Chart Data ---
                 // Generate dummy data for the chart based on the selected variables
                 // This is a simplified aggregation
                 const uniqueTimepoints = Array.from(new Set(appState.processedData.map(d => d[config.timeVar]))).sort((a, b) => a - b); // Sort numeric timepoints
                 const uniqueInterventions = Array.from(new Set(appState.processedData.map(d => d[config.independentVar]))).sort();

                 const chartData = {
                     labels: uniqueTimepoints,
                     datasets: []
                 };

                 uniqueInterventions.forEach((intervention, index) => {
                      // Use HSL for color variation based on index
                      const hue = (index * (300 / uniqueInterventions.length) + 60) % 360; // Start hue away from red/green
                      const color = `hsl(${hue}, 70%, 50%)`;

                     const dataset = {
                         label: `${config.dependentVar} (${intervention})`,
                         data: [],
                         borderColor: color,
                         backgroundColor: `${color.replace(')', ', 0.6)')}`, // Add transparency
                         tension: chartType === 'line' ? 0.3 : 0, // Add some curve to lines
                         fill: false,
                         pointRadius: chartType === 'line' || chartType === 'scatter' ? 6 : 0,
                         pointHoverRadius: chartType === 'line' || chartType === 'scatter' ? 8 : 0,
                         barPercentage: chartType === 'bar' ? 0.8 : undefined,
                         categoryPercentage: chartType === 'bar' ? 0.8 : undefined,
                         // Store original color for updates
                         _originalColor: color
                     };

                     uniqueTimepoints.forEach(timepoint => {
                         // Calculate average dependent variable for this intervention and timepoint
                         const filteredData = appState.processedData.filter(d =>
                             d[config.independentVar] === intervention && d[config.timeVar] === timepoint
                         );
                         const averageValue = filteredData.reduce((sum, d) => sum + parseFloat(d[config.dependentVar]), 0) / filteredData.length;
                         dataset.data.push(averageValue || 0); // Handle division by zero
                     });
                     chartData.datasets.push(dataset);
                 });


                 const chartConfig = {
                     type: chartType === 'box' ? 'bar' : chartType, // Use bar as fallback for box plot without plugin
                     data: chartData,
                     options: {
                         responsive: true,
                         maintainAspectRatio: false,
                         plugins: {
                             legend: {
                                 position: 'top',
                             },
                             title: {
                                 display: true,
                                 text: `${config.dependentVar} by ${config.independentVar} over Time`,
                                 font: { size: 16, weight: 'bold' }
                             },
                             tooltip: {
                                 callbacks: {
                                     label: function(context) {
                                         let label = context.dataset.label || '';
                                         if (label) {
                                             label += ': ';
                                         }
                                         if (context.parsed.y !== undefined) {
                                             label += context.parsed.y.toFixed(2);
                                         }
                                         // Add more detail for scatter plot points if needed (requires iterating original data)
                                         // Example: Find the original data point associated with this tooltip
                                         // This is complex with aggregated data; would need non-aggregated data for scatter
                                         return label;
                                     }
                                 }
                             }
                         },
                         scales: {
                             x: {
                                 title: {
                                     display: true,
                                     text: config.timeVar
                                 }
                             },
                             y: {
                                 title: {
                                     display: true,
                                     text: config.dependentVar
                                 }
                             }
                         }
                     }
                 };

                 const ctx = canvas.getContext('2d');
                 const newChart = new Chart(ctx, chartConfig);

                 appState.charts.push({
                     id: chartId,
                     chartInstance: newChart,
                     config: chartConfig // Store config for potential updates/export
                 });

                 // Add event listeners for floating controls
                 const toggleBtn = document.getElementById(`toggle-controls-${chartId}`);
                 const controlPanelContent = controls.querySelector('.control-panel-content');
                 toggleBtn.addEventListener('click', () => {
                     const isVisible = controlPanelContent.style.display !== 'none';
                     controlPanelContent.style.display = isVisible ? 'none' : 'flex';
                     controls.setAttribute('aria-expanded', !isVisible);
                 });

                 document.getElementById(`chartType-${chartId}`).addEventListener('change', (e) => updateChartType(chartId, e.target.value));
                 document.getElementById(`color-${chartId}`).addEventListener('input', (e) => updateChartColor(chartId, e.target.value));
                 document.getElementById(`filter-subgroup-${chartId}`).addEventListener('change', (e) => filterChartBySubgroup(chartId, e.target.value, config.dependentVar, config.independentVar, config.timeVar));
                 document.getElementById(`export-chart-${chartId}`).addEventListener('click', () => exportChart(newChart, chartId, 'png'));


                 hideLoading();
             }, 500); // Simulate data prep time
        }

        function updateChartType(chartId, newType) {
            const chartEntry = appState.charts.find(c => c.id === chartId);
            if (chartEntry) {
                // Note: Changing type might require data structure adjustments for some types (e.g., boxplot)
                // This simple update works for compatible types (line, bar, scatter)
                // For boxplot, it will fall back to bar as defined in generateChart
                chartEntry.chartInstance.config.type = newType === 'box' ? 'bar' : newType; // Apply fallback logic
                chartEntry.chartInstance.update();
            }
        }

         function updateChartColor(chartId, newColor) {
            const chartEntry = appState.charts.find(c => c.id === chartId);
            if (chartEntry && chartEntry.chartInstance.data.datasets.length > 0) {
                 // Apply color to all datasets, potentially modifying based on original hue
                 chartEntry.chartInstance.data.datasets.forEach(dataset => {
                     // Simple example: just set border/background directly
                     dataset.borderColor = newColor;
                     dataset.backgroundColor = newColor + '99'; // Add some transparency (99 is ~60%)
                     // A more advanced approach would adjust hue while keeping saturation/lightness
                 });
                chartEntry.chartInstance.update();
            }
        }

        function filterChartBySubgroup(chartId, selectedSubgroupVar, depVar, indepVar, timeVar) {
             const chartEntry = appState.charts.find(c => c.id === chartId);
             if (!chartEntry || !appState.processedData) return;

             showLoading();

             // Re-generate data based on the selected subgroup filter
             let filteredData = appState.processedData;
             if (selectedSubgroupVar !== 'all') {
                 // Filter data to only include rows where the selected subgroup variable is 'Yes'
                 // This assumes subgroup variables are binary ('Yes'/'No')
                 filteredData = appState.processedData.filter(d => d[selectedSubgroupVar] === 'Yes');
             }

             const uniqueTimepoints = Array.from(new Set(filteredData.map(d => d[timeVar]))).sort((a, b) => a - b);
             const uniqueInterventions = Array.from(new Set(filteredData.map(d => d[indepVar]))).sort();

             const newDatasets = [];

             uniqueInterventions.forEach((intervention, index) => {
                  const hue = (index * (300 / uniqueInterventions.length) + 60) % 360;
                  const color = `hsl(${hue}, 70%, 50%)`;

                 const dataset = {
                     label: `${depVar} (${intervention})`,
                     data: [],
                     borderColor: color,
                     backgroundColor: `${color.replace(')', ', 0.6)')}`,
                     tension: chartEntry.chartInstance.config.type === 'line' ? 0.3 : 0,
                     fill: false,
                     pointRadius: chartEntry.chartInstance.config.type === 'line' || chartEntry.chartInstance.config.type === 'scatter' ? 6 : 0,
                     pointHoverRadius: chartEntry.chartInstance.config.type === 'line' || chartEntry.chartInstance.config.type === 'scatter' ? 8 : 0,
                     barPercentage: chartEntry.chartInstance.config.type === 'bar' ? 0.8 : undefined,
                     categoryPercentage: chartEntry.chartInstance.config.type === 'bar' ? 0.8 : undefined,
                 };

                 uniqueTimepoints.forEach(timepoint => {
                     const dataAtTimepoint = filteredData.filter(d =>
                         d[indepVar] === intervention && d[timeVar] === timepoint
                     );
                     const averageValue = dataAtTimepoint.reduce((sum, d) => sum + parseFloat(d[depVar]), 0) / dataAtTimepoint.length;
                     dataset.data.push(averageValue || 0);
                 });
                 newDatasets.push(dataset);
             });

             // Update chart data and labels
             chartEntry.chartInstance.data.labels = uniqueTimepoints;
             chartEntry.chartInstance.data.datasets = newDatasets;

             // Update chart title to reflect filter
             const filterLabel = selectedSubgroupVar === 'all' ? 'All Students' : `${selectedSubgroupVar} Students`;
             chartEntry.chartInstance.options.plugins.title.text = `${depVar} by ${indepVar} over Time (${filterLabel})`;


             chartEntry.chartInstance.update();
             hideLoading();
        }


        // --- Export ---
        function openExportModal() {
             // Populate export content options
             exportContentSelect.innerHTML = '';
             exportContentSelect.innerHTML += '<option value="data">Processed Data</option>';
             if (appState.analysisResults) {
                exportContentSelect.innerHTML += '<option value="results">Analysis Results</option>';
             } else {
                 exportContentSelect.innerHTML += '<option value="results" disabled>Analysis Results (None available)</option>';
             }

             if (appState.charts.length > 0) {
                 exportContentSelect.innerHTML += '<option value="all-charts">All Charts (PNG)</option>';
                 appState.charts.forEach(chart => {
                     exportContentSelect.innerHTML += `<option value="${chart.id}">${chart.id} (PNG)</option>`;
                 });
             } else {
                  exportContentSelect.innerHTML += '<option value="all-charts" disabled>All Charts (None available)</option>';
             }


             showModal('export-modal');
        }

        function exportContent() {
             const format = exportFormatSelect.value;
             const content = exportContentSelect.value;

             if (content === 'data' && appState.processedData) {
                 if (format === 'csv') {
                     downloadCSV(appState.processedData, 'processed_data.csv');
                 } else if (format === 'json') {
                     downloadJSON(appState.processedData, 'processed_data.json');
                 } else {
                     alert('Selected format not supported for data export.');
                 }
             } else if (content === 'results' && appState.analysisResults) {
                  // Simple export of all results tables as CSV/JSON
                  if(appState.analysisResults.tables.length > 0) {
                      // Prepare data for CSV/JSON export
                      const allResultsData = appState.analysisResults.tables.reduce((acc, table) => {
                           // Add table title as a row for context in CSV/JSON
                           acc.push([`## ${table.title} ##`]);
                           acc.push(table.headers);
                           acc.push(...table.rows);
                           acc.push([]); // Add a blank row between tables
                           return acc;
                      }, []);

                       if (format === 'csv') {
                           downloadCSV(allResultsData, 'analysis_results.csv');
                       } else if (format === 'json') {
                           // Convert to a structured JSON format
                           const jsonResults = appState.analysisResults.tables.map(table => ({
                               title: table.title,
                               headers: table.headers,
                               rows: table.rows.map(row => {
                                   const obj = {};
                                   table.headers.forEach((header, i) => {
                                       obj[header] = row[i];
                                   });
                                   return obj;
                               })
                           }));
                           downloadJSON(jsonResults, 'analysis_results.json');
                       } else {
                            alert('Selected format not supported for results export.');
                       }
                  } else {
                      alert('No results tables to export.');
                  }

             } else if (content === 'all-charts') {
                 if (format === 'png') {
                      appState.charts.forEach(chartEntry => {
                          exportChart(chartEntry.chartInstance, chartEntry.id, 'png');
                      });
                 } else {
                     alert('Selected format not supported for all charts export.');
                 }
             } else if (content.startsWith('chart-')) {
                 const chartEntry = appState.charts.find(c => c.id === content);
                 if (chartEntry) {
                     exportChart(chartEntry.chartInstance, chartEntry.id, format);
                 } else {
                      alert('Chart not found.');
                 }
             } else {
                 alert('No content selected or available for export.');
             }

             closeModal('export-modal');
        }

        function downloadCSV(data, filename) {
            const csvRows = data.map(row =>
                Array.isArray(row) ? row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',') :
                Object.values(row).map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
            );
            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
             // Clean up the URL object after download
            link.addEventListener('load', () => URL.revokeObjectURL(link.href), { once: true });
        }

         function downloadJSON(data, filename) {
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
             // Clean up the URL object after download
             link.addEventListener('load', () => URL.revokeObjectURL(link.href), { once: true });
        }

        function exportChart(chartInstance, chartId, format) {
            if (format === 'png') {
                const link = document.createElement('a');
                link.href = chartInstance.toBase64Image();
                link.download = `${chartId}.png`;
                link.click();
                 // Clean up the URL object after download
                link.addEventListener('load', () => URL.revokeObjectURL(link.href), { once: true });
            } else if (format === 'svg') {
                // Chart.js does not natively support SVG export without plugins
                alert('SVG export requires additional libraries or plugins.');
                // Placeholder for potential future implementation
            } else {
                alert(`Export format "${format}" not supported for charts.`);
            }
        }


        // --- Event Listeners ---

        // File Upload Drag and Drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            // document.body.addEventListener(eventName, preventDefaults, false); // Prevent default for body too - can interfere with other drag/drop
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('dragover'), false);
        });

        dropArea.addEventListener('drop', handleDrop, false);
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        // Process Data Button
        processDataBtn.addEventListener('click', processData);

        // Analysis Config Changes - Use event delegation for checkboxes/radios
        dependentVarSelect.addEventListener('change', updateSelectedConfig);
        independentVarSelect.addEventListener('change', updateSelectedConfig);
        timeVarSelect.addEventListener('change', updateSelectedConfig);
        confoundingVarsSelect.addEventListener('change', updateSelectedConfig);
        subgroupOptionsDiv.addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                updateSelectedConfig();
            }
        });
        analysisTypeOptionsDiv.addEventListener('change', (e) => {
             if (e.target.type === 'radio' && e.target.name === 'analysisType') {
                 updateSelectedConfig();
             }
        });


        // Run Analysis Button
        runAnalysisBtn.addEventListener('click', runAnalysis);

        // Generate Chart Button
        generateChartBtn.addEventListener('click', generateChart);

        // Export Button
        openExportModalBtn.addEventListener('click', openExportModal);
        exportConfirmBtn.addEventListener('click', exportContent);

        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && exportModal.classList.contains('visible')) {
                closeModal('export-modal');
            }
        });

         // Close floating controls when clicking outside
        document.addEventListener('click', (e) => {
            // Check if the click is outside any floating-controls and not on a toggle button
            if (!e.target.closest('.floating-controls') && !e.target.matches('[id^="toggle-controls-"]')) {
                document.querySelectorAll('.floating-controls').forEach(controls => {
                     const content = controls.querySelector('.control-panel-content');
                     if (content.style.display !== 'none') {
                         content.style.display = 'none';
                         controls.setAttribute('aria-expanded', 'false');
                     }
                });
            }
        });


        // Initial state setup
        renderFileList(); // Show "No files selected" initially
        disableElement(processDataBtn);
        disableElement(dependentVarSelect);
        disableElement(independentVarSelect);
        disableElement(timeVarSelect);
        disableElement(confoundingVarsSelect);
        subgroupOptionsDiv.querySelectorAll('input').forEach(disableElement);
        analysisTypeOptionsDiv.querySelectorAll('input').forEach(disableElement);
        disableElement(runAnalysisBtn);
        disableElement(chartTypeSelector);
        disableElement(generateChartBtn);
        disableElement(openExportModalBtn);


    </script>

</body>
</html>
