<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sleep & Academic Performance Analysis Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />
    <style>
        :root {
            --primary: #4361ee;
            --primary-light: #4895ef;
            --primary-dark: #3f37c9;
            --secondary: #f72585;
            --accent: #7209b7;
            --text-primary: #333333;
            --text-secondary: #6c757d;
            --background: #ffffff;
            --background-secondary: #f8f9fa;
            --border: #dee2e6;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --shadow: rgba(0, 0, 0, 0.1);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            background-color: var(--background-secondary);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-dark);
            margin-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 1rem;
        }

        h3 {
            font-size: 1.2rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .description {
            max-width: 800px;
            margin: 0 auto 2rem;
            color: var(--text-secondary);
        }

        .card {
            background: var(--background);
            border-radius: var(--radius);
            box-shadow: 0 4px 6px var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .workflow {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
        }

        .workflow-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            text-align: center;
            padding: 1rem;
            position: relative;
        }

        .workflow-step:not(:last-child)::after {
            content: "";
            position: absolute;
            top: 2.5rem;
            right: -1rem;
            width: 2rem;
            height: 2px;
            background-color: var(--border);
        }

        .step-number {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            background-color: var(--primary-light);
            color: white;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .step-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .step-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .upload-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            background-color: var(--background);
            cursor: pointer;
            transition: var(--transition);
        }

        .upload-section:hover {
            border-color: var(--primary-light);
        }

        .upload-icon {
            font-size: 3rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }

        .upload-text {
            margin-bottom: 1rem;
            text-align: center;
        }

        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1.5rem;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }

        .button:hover {
            background-color: var(--primary-dark);
        }

        .button-secondary {
            background-color: var(--background);
            color: var(--primary);
            border: 1px solid var(--primary);
        }

        .button-secondary:hover {
            background-color: var(--primary-light);
            color: white;
        }

        .button-icon {
            margin-right: 0.5rem;
        }

        .data-preview {
            overflow-x: auto;
            margin-top: 1.5rem;
            display: none;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th, .data-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .data-table th {
            background-color: var(--background-secondary);
            font-weight: 600;
        }

        .data-table tr:hover {
            background-color: var(--background-secondary);
        }

        .analysis-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .option-group {
            margin-bottom: 1.5rem;
        }

        .option-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .select-wrapper {
            position: relative;
        }

        .select-wrapper::after {
            content: "arrow_drop_down";
            font-family: 'Material Symbols Rounded';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
        }

        select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background-color: var(--background);
            font-family: inherit;
            font-size: 1rem;
            appearance: none;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .checkbox-label input {
            margin-right: 0.5rem;
        }

        .analysis-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            display: none;
        }

        .result-card {
            padding: 1.5rem;
            border-radius: var(--radius);
            background-color: var(--background);
            box-shadow: 0 4px 6px var(--shadow);
        }

        .result-title {
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .result-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .result-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .visualization-section {
            display: none;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 1.5rem;
        }

        .chart-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .help-text {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .error-message {
            color: var(--danger);
            margin-top: 0.5rem;
            display: none;
        }

        .floating-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 10;
        }

        .floating-controls.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .control-group {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        @media (max-width: 768px) {
            .workflow {
                flex-direction: column;
            }

            .workflow-step:not(:last-child)::after {
                top: auto;
                right: 50%;
                bottom: -1rem;
                transform: translateX(50%) rotate(90deg);
                width: 2rem;
            }

            .analysis-options,
            .analysis-results {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Sleep & Academic Performance Analysis</h1>
            <p class="description">
                This tool helps university students analyze the relationship between sleep patterns and academic performance.
                Upload your data, select variables for analysis, and visualize correlations to identify meaningful patterns for your dissertation.
            </p>
        </header>

        <div class="card">
            <h2>Workflow</h2>
            <div class="workflow">
                <div class="workflow-step">
                    <div class="step-number">1</div>
                    <div class="step-title">Upload Data</div>
                    <div class="step-description">Upload your CSV file with sleep and academic data</div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">2</div>
                    <div class="step-title">Select Variables</div>
                    <div class="step-description">Choose variables for analysis and visualization</div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">3</div>
                    <div class="step-title">Analyze</div>
                    <div class="step-description">View statistical analysis of your data</div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">4</div>
                    <div class="step-title">Visualize</div>
                    <div class="step-description">Explore interactive visualizations of correlations</div>
                </div>
            </div>
        </div>

        <div class="card" id="upload-card">
            <h2>Upload Your Data</h2>
            <p>Upload a CSV file containing your sleep and academic performance data.</p>
            
            <div class="upload-section" id="upload-area">
                <span class="material-symbols-rounded upload-icon">cloud_upload</span>
                <p class="upload-text">Drag and drop your CSV file here or click to browse</p>
                <button class="button">
                    <span class="material-symbols-rounded button-icon">upload_file</span>
                    Select CSV File
                </button>
                <input type="file" id="file-input" accept=".csv" style="display: none;">
                <p class="help-text">Your file should include columns for sleep duration, sleep quality, class attendance, and test scores.</p>
                <div class="error-message" id="upload-error"></div>
            </div>

            <div class="data-preview" id="data-preview">
                <h3>Data Preview</h3>
                <div style="overflow-x: auto;">
                    <table class="data-table" id="data-table">
                        <!-- Data will be loaded here -->
                    </table>
                </div>
            </div>
        </div>

        <div class="card" id="analysis-card" style="display: none;">
            <h2>Select Variables for Analysis</h2>
            <p>Choose which variables you want to analyze and visualize.</p>
            
            <div class="analysis-options">
                <div class="option-group">
                    <label class="option-label">Sleep Variables</label>
                    <div class="checkbox-group" id="sleep-variables">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
                
                <div class="option-group">
                    <label class="option-label">Academic Variables</label>
                    <div class="checkbox-group" id="academic-variables">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>

            <div class="option-group">
                <label class="option-label">Analysis Type</label>
                <div class="select-wrapper">
                    <select id="analysis-type">
                        <option value="correlation">Correlation Analysis</option>
                        <option value="regression">Regression Analysis</option>
                        <option value="comparison">Group Comparison</option>
                    </select>
                </div>
                <p class="help-text">Correlation analysis measures the strength of relationships between variables. Regression analysis predicts one variable based on others. Group comparison analyzes differences between categories.</p>
            </div>

            <button class="button" id="analyze-button">
                <span class="material-symbols-rounded button-icon">analytics</span>
                Analyze Data
            </button>
        </div>

        <div class="card" id="results-card" style="display: none;">
            <h2>Analysis Results</h2>
            <p>Statistical analysis of the relationship between selected variables.</p>
            
            <div class="analysis-results" id="analysis-results">
                <!-- Results will be populated here -->
            </div>

            <div class="visualization-section" id="visualization-section">
                <h3>Data Visualization</h3>
                <div class="chart-controls">
                    <div class="option-group">
                        <label class="option-label">Chart Type</label>
                        <div class="select-wrapper">
                            <select id="chart-type">
                                <option value="scatter">Scatter Plot</option>
                                <option value="bar">Bar Chart</option>
                                <option value="heatmap">Correlation Heatmap</option>
                                <option value="line">Line Chart</option>
                            </select>
                        </div>
                    </div>
                    <button class="button" id="generate-chart-button">
                        <span class="material-symbols-rounded button-icon">bar_chart</span>
                        Generate Chart
                    </button>
                </div>

                <div class="chart-container">
                    <canvas id="chart-canvas"></canvas>
                    <div class="floating-controls" id="chart-controls">
                        <div class="control-group">
                            <label>Chart Title</label>
                            <input type="text" id="chart-title" value="Sleep vs. Academic Performance">
                        </div>
                        <div class="control-group">
                            <label>X-Axis Variable</label>
                            <select id="x-axis-variable">
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Y-Axis Variable</label>
                            <select id="y-axis-variable">
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Color Scheme</label>
                            <select id="color-scheme">
                                <option value="default">Default</option>
                                <option value="cool">Cool Colors</option>
                                <option value="warm">Warm Colors</option>
                                <option value="pastel">Pastel</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Show Regression Line</label>
                            <input type="checkbox" id="show-regression">
                        </div>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 1rem;">
                <button class="button button-secondary" id="export-results-button">
                    <span class="material-symbols-rounded button-icon">download</span>
                    Export Results
                </button>
                <button class="button button-secondary" id="export-chart-button">
                    <span class="material-symbols-rounded button-icon">image</span>
                    Export Chart
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { Chart } from "https://esm.sh/chart.js/auto";
        import { regression } from "https://esm.sh/regression";

        // Global variables
        let parsedData = [];
        let columnNames = [];
        let chart = null;

        // DOM Elements
        const fileInput = document.getElementById('file-input');
        const uploadArea = document.getElementById('upload-area');
        const dataPreview = document.getElementById('data-preview');
        const dataTable = document.getElementById('data-table');
        const uploadError = document.getElementById('upload-error');
        const analysisCard = document.getElementById('analysis-card');
        const sleepVariables = document.getElementById('sleep-variables');
        const academicVariables = document.getElementById('academic-variables');
        const analysisType = document.getElementById('analysis-type');
        const analyzeButton = document.getElementById('analyze-button');
        const resultsCard = document.getElementById('results-card');
        const analysisResults = document.getElementById('analysis-results');
        const visualizationSection = document.getElementById('visualization-section');
        const chartType = document.getElementById('chart-type');
        const generateChartButton = document.getElementById('generate-chart-button');
        const chartCanvas = document.getElementById('chart-canvas');
        const chartControls = document.getElementById('chart-controls');
        const xAxisVariable = document.getElementById('x-axis-variable');
        const yAxisVariable = document.getElementById('y-axis-variable');
        const colorScheme = document.getElementById('color-scheme');
        const showRegression = document.getElementById('show-regression');
        const chartTitle = document.getElementById('chart-title');
        const exportResultsButton = document.getElementById('export-results-button');
        const exportChartButton = document.getElementById('export-chart-button');

        // Color schemes
        const colorSchemes = {
            default: ['#4361ee', '#3a0ca3', '#f72585', '#4cc9f0'],
            cool: ['#0077b6', '#00b4d8', '#90e0ef', '#caf0f8'],
            warm: ['#ff7b00', '#ff9e00', '#ffb700', '#ffd000'],
            pastel: ['#ffd6ff', '#e7c6ff', '#c8b6ff', '#b8c0ff']
        };

        // Initialize the application
        function init() {
            // Set up event listeners
            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileUpload);
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);
            analyzeButton.addEventListener('click', analyzeData);
            generateChartButton.addEventListener('click', generateChart);
            chartCanvas.addEventListener('click', toggleChartControls);
            document.addEventListener('click', (e) => {
                if (!chartCanvas.contains(e.target) && !chartControls.contains(e.target)) {
                    chartControls.classList.remove('active');
                }
            });
            exportResultsButton.addEventListener('click', exportResults);
            exportChartButton.addEventListener('click', exportChart);

            // Set up chart controls event listeners
            chartTitle.addEventListener('change', updateChart);
            xAxisVariable.addEventListener('change', updateChart);
            yAxisVariable.addEventListener('change', updateChart);
            colorScheme.addEventListener('change', updateChart);
            showRegression.addEventListener('change', updateChart);
        }

        // File upload handlers
        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--primary)';
            uploadArea.style.backgroundColor = 'var(--background-secondary)';
        }

        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--border)';
            uploadArea.style.backgroundColor = 'var(--background)';
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--border)';
            uploadArea.style.backgroundColor = 'var(--background)';
            
            const files = e.dataTransfer.files;
            if (files.length) {
                fileInput.files = files;
                handleFileUpload();
            }
        }

        function handleFileUpload() {
            const file = fileInput.files[0];
            if (!file) return;

            if (file.type !== 'text/csv' && !file.name.endsWith('.csv')) {
                showError('Please upload a CSV file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    parseCSV(e.target.result);
                    uploadError.style.display = 'none';
                } catch (error) {
                    showError('Error parsing CSV file. Please check the format.');
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        function showError(message) {
            uploadError.textContent = message;
            uploadError.style.display = 'block';
        }

        function parseCSV(csvText) {
            // Simple CSV parsing (for a more robust solution, you might want to use a library like PapaParse)
            const lines = csvText.split('\n');
            columnNames = lines[0].split(',').map(name => name.trim());
            
            parsedData = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                
                const values = lines[i].split(',');
                const row = {};
                
                for (let j = 0; j < columnNames.length; j++) {
                    const value = values[j]?.trim();
                    row[columnNames[j]] = isNaN(value) ? value : parseFloat(value);
                }
                
                parsedData.push(row);
            }

            displayDataPreview();
            populateVariableSelectors();
            analysisCard.style.display = 'block';
        }

        function displayDataPreview() {
            // Clear previous data
            dataTable.innerHTML = '';
            
            // Create header row
            const headerRow = document.createElement('tr');
            columnNames.forEach(name => {
                const th = document.createElement('th');
                th.textContent = name;
                headerRow.appendChild(th);
            });
            dataTable.appendChild(headerRow);
            
            // Add data rows (show only first 5 rows)
            const maxRows = Math.min(5, parsedData.length);
            for (let i = 0; i < maxRows; i++) {
                const row = document.createElement('tr');
                
                columnNames.forEach(column => {
                    const td = document.createElement('td');
                    td.textContent = parsedData[i][column];
                    row.appendChild(td);
                });
                
                dataTable.appendChild(row);
            }
            
            // Show preview section
            dataPreview.style.display = 'block';
        }

        function populateVariableSelectors() {
            // Clear previous options
            sleepVariables.innerHTML = '';
            academicVariables.innerHTML = '';
            xAxisVariable.innerHTML = '';
            yAxisVariable.innerHTML = '';
            
            // Add common sleep-related variables
            const sleepKeywords = ['sleep', 'bed', 'wake', 'rest', 'nap', 'fatigue'];
            const academicKeywords = ['score', 'grade', 'exam', 'test', 'attendance', 'performance', 'gpa'];
            
            columnNames.forEach(column => {
                const lowerColumn = column.toLowerCase();
                
                // Create checkbox for the variable selector
                const checkboxLabel = document.createElement('label');
                checkboxLabel.className = 'checkbox-label';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = column;
                
                checkboxLabel.appendChild(checkbox);
                checkboxLabel.appendChild(document.createTextNode(column));
                
                // Determine if it's a sleep or academic variable based on keywords
                let isSleep = sleepKeywords.some(keyword => lowerColumn.includes(keyword));
                let isAcademic = academicKeywords.some(keyword => lowerColumn.includes(keyword));
                
                if (isSleep) {
                    sleepVariables.appendChild(checkboxLabel);
                } else if (isAcademic) {
                    academicVariables.appendChild(checkboxLabel);
                } else {
                    // If we can't determine, add to both
                    sleepVariables.appendChild(checkboxLabel.cloneNode(true));
                    academicVariables.appendChild(checkboxLabel);
                }
                
                // Add option to axis selectors
                const option = document.createElement('option');
                option.value = column;
                option.textContent = column;
                
                xAxisVariable.appendChild(option.cloneNode(true));
                yAxisVariable.appendChild(option.cloneNode(true));
            });
            
            // Select first options by default for the chart axes
            if (xAxisVariable.options.length > 0) {
                xAxisVariable.selectedIndex = 0;
            }
            if (yAxisVariable.options.length > 1) {
                yAxisVariable.selectedIndex = 1;
            }
        }

        function analyzeData() {
            // Get selected variables
            const selectedSleepVars = Array.from(sleepVariables.querySelectorAll('input:checked')).map(input => input.value);
            const selectedAcademicVars = Array.from(academicVariables.querySelectorAll('input:checked')).map(input => input.value);
            
            if (selectedSleepVars.length === 0 || selectedAcademicVars.length === 0) {
                alert('Please select at least one sleep variable and one academic variable.');
                return;
            }

            // Perform analysis based on selected type
            const analysisMethod = analysisType.value;
            let results = [];
            
            if (analysisMethod === 'correlation') {
                results = calculateCorrelations(selectedSleepVars, selectedAcademicVars);
            } else if (analysisMethod === 'regression') {
                results = performRegression(selectedSleepVars, selectedAcademicVars);
            } else if (analysisMethod === 'comparison') {
                results = performGroupComparison(selectedSleepVars, selectedAcademicVars);
            }
            
            displayResults(results, analysisMethod);
            resultsCard.style.display = 'block';
            visualizationSection.style.display = 'block';
            
            // Scroll to results
            resultsCard.scrollIntoView({ behavior: 'smooth' });
        }

        function calculateCorrelations(sleepVars, academicVars) {
            const results = [];
            
            for (const sleepVar of sleepVars) {
                for (const academicVar of academicVars) {
                    const correlation = calculatePearsonCorrelation(sleepVar, academicVar);
                    
                    results.push({
                        title: `${sleepVar} vs ${academicVar}`,
                        value: correlation.toFixed(2),
                        description: interpretCorrelation(correlation),
                        variables: [sleepVar, academicVar]
                    });
                }
            }
            
            return results;
        }

        function calculatePearsonCorrelation(var1, var2) {
            const validData = parsedData.filter(row => 
                typeof row[var1] === 'number' && 
                !isNaN(row[var1]) && 
                typeof row[var2] === 'number' && 
                !isNaN(row[var2])
            );
            
            if (validData.length < 3) return 0;
            
            const values1 = validData.map(row => row[var1]);
            const values2 = validData.map(row => row[var2]);
            
            const mean1 = values1.reduce((sum, val) => sum + val, 0) / values1.length;
            const mean2 = values2.reduce((sum, val) => sum + val, 0) / values2.length;
            
            let numerator = 0;
            let denom1 = 0;
            let denom2 = 0;
            
            for (let i = 0; i < values1.length; i++) {
                const diff1 = values1[i] - mean1;
                const diff2 = values2[i] - mean2;
                
                numerator += diff1 * diff2;
                denom1 += diff1 * diff1;
                denom2 += diff2 * diff2;
            }
            
            if (denom1 === 0 || denom2 === 0) return 0;
            
            return numerator / Math.sqrt(denom1 * denom2);
        }

        function interpretCorrelation(correlation) {
            const absCorr = Math.abs(correlation);
            
            if (absCorr < 0.1) return 'No correlation';
            if (absCorr < 0.3) return 'Weak correlation';
            if (absCorr < 0.5) return 'Moderate correlation';
            if (absCorr < 0.7) return 'Strong correlation';
            return 'Very strong correlation';
        }

        function performRegression(sleepVars, academicVars) {
            const results = [];
            
            for (const sleepVar of sleepVars) {
                for (const academicVar of academicVars) {
                    const validData = parsedData.filter(row => 
                        typeof row[sleepVar] === 'number' && 
                        !isNaN(row[sleepVar]) && 
                        typeof row[academicVar] === 'number' && 
                        !isNaN(row[academicVar])
                    );
                    
                    if (validData.length < 3) continue;
                    
                    const x = validData.map(row => row[sleepVar]);
                    const y = validData.map(row => row[academicVar]);
                    
                    // Calculate linear regression manually
                    const n = x.length;
                    const sumX = x.reduce((a, b) => a + b, 0);
                    const sumY = y.reduce((a, b) => a + b, 0);
                    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
                    const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
                    
                    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                    const intercept = (sumY - slope * sumX) / n;
                    
                    // Calculate R-squared
                    const yMean = sumY / n;
                    const ssTotal = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);
                    const ssResidual = y.reduce((sum, yi, i) => {
                        const prediction = slope * x[i] + intercept;
                        return sum + Math.pow(yi - prediction, 2);
                    }, 0);
                    const rSquared = 1 - (ssResidual / ssTotal);
                    
                    results.push({
                        title: `${sleepVar} → ${academicVar}`,
                        value: rSquared.toFixed(2),
                        description: `R² = ${rSquared.toFixed(2)}. ${interpretRSquared(rSquared)}`,
                        equation: `${academicVar} = ${slope.toFixed(2)} × ${sleepVar} + ${intercept.toFixed(2)}`,
                        variables: [sleepVar, academicVar],
                        slope,
                        intercept
                    });
                }
            }
            
            return results;
        }

        function interpretRSquared(rSquared) {
            if (rSquared < 0.1) return 'Very weak predictive power';
            if (rSquared < 0.3) return 'Weak predictive power';
            if (rSquared < 0.5) return 'Moderate predictive power';
            if (rSquared < 0.7) return 'Strong predictive power';
            return 'Very strong predictive power';
        }

        function performGroupComparison(sleepVars, academicVars) {
            const results = [];
            
            for (const sleepVar of sleepVars) {
                // Check if the sleep variable can be used for grouping
                const uniqueValues = [...new Set(parsedData.map(row => row[sleepVar]))];
                
                // If too many unique values, skip or bin the data
                if (uniqueValues.length > 5) {
                    // For numeric variables, create bins
                    if (typeof parsedData[0][sleepVar] === 'number') {
                        const groups = binNumericData(sleepVar);
                        
                        for (const academicVar of academicVars) {
                            const groupComparisons = compareGroups(groups, academicVar);
                            
                            results.push({
                                title: `${sleepVar} Groups vs ${academicVar}`,
                                value: groupComparisons.fValue.toFixed(2),
                                description: `F = ${groupComparisons.fValue.toFixed(2)}. ${interpretFValue(groupComparisons.fValue)}`,
                                groups: groupComparisons.groups,
                                variables: [sleepVar, academicVar]
                            });
                        }
                    }
                } else {
                    // For categorical variables or variables with few unique values
                    const groups = {};
                    
                    for (const row of parsedData) {
                        const groupValue = row[sleepVar];
                        if (!groups[groupValue]) {
                            groups[groupValue] = [];
                        }
                        groups[groupValue].push(row);
                    }
                    
                    for (const academicVar of academicVars) {
                        const groupComparisons = compareGroups(groups, academicVar);
                        
                        results.push({
                            title: `${sleepVar} Groups vs ${academicVar}`,
                            value: groupComparisons.fValue.toFixed(2),
                            description: `F = ${groupComparisons.fValue.toFixed(2)}. ${interpretFValue(groupComparisons.fValue)}`,
                            groups: groupComparisons.groups,
                            variables: [sleepVar, academicVar]
                        });
                    }
                }
            }
            
            return results;
        }

        function binNumericData(variable) {
            // Get min and max values
            const values = parsedData
                .map(row => row[variable])
                .filter(val => typeof val === 'number' && !isNaN(val));
            
            const min = Math.min(...values);
            const max = Math.max(...values);
            
            // Create 3 bins
            const binSize = (max - min) / 3;
            const bins = {
                [`${variable} (Low)`]: [],
                [`${variable} (Medium)`]: [],
                [`${variable} (High)`]: []
            };
            
            // Assign data to bins
            for (const row of parsedData) {
                const value = row[variable];
                if (typeof value !== 'number' || isNaN(value)) continue;
                
                if (value < min + binSize) {
                    bins[`${variable} (Low)`].push(row);
                } else if (value < min + 2 * binSize) {
                    bins[`${variable} (Medium)`].push(row);
                } else {
                    bins[`${variable} (High)`].push(row);
                }
            }
            
            return bins;
        }

        function compareGroups(groups, academicVar) {
            const groupStats = {};
            let totalSum = 0;
            let totalSumSquared = 0;
            let totalN = 0;
            
            // Calculate statistics for each group
            for (const groupName in groups) {
                const groupValues = groups[groupName]
                    .map(row => row[academicVar])
                    .filter(val => typeof val === 'number' && !isNaN(val));
                
                if (groupValues.length < 2) continue;
                
                const sum = groupValues.reduce((a, b) => a + b, 0);
                const mean = sum / groupValues.length;
                const sumSquared = groupValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
                const variance = sumSquared / (groupValues.length - 1);
                
                groupStats[groupName] = {
                    n: groupValues.length,
                    mean,
                    variance,
                    sum,
                    sumSquared
                };
                
                totalSum += sum;
                totalSumSquared += groupValues.reduce((sum, val) => sum + val * val, 0);
                totalN += groupValues.length;
            }
            
            // Calculate F-statistic (simplified ANOVA)
            const grandMean = totalSum / totalN;
            
            let betweenGroupSS = 0;
            let withinGroupSS = 0;
            
            for (const groupName in groupStats) {
                const stats = groupStats[groupName];
                betweenGroupSS += stats.n * Math.pow(stats.mean - grandMean, 2);
                withinGroupSS += (stats.n - 1) * stats.variance;
            }
            
            const groupCount = Object.keys(groupStats).length;
            const betweenDf = groupCount - 1;
            const withinDf = totalN - groupCount;
            
            if (betweenDf <= 0 || withinDf <= 0) {
                return { fValue: 0, groups: groupStats };
            }
            
            const betweenMS = betweenGroupSS / betweenDf;
            const withinMS = withinGroupSS / withinDf;
            
            const fValue = betweenMS / withinMS;
            
            return { fValue, groups: groupStats };
        }

        function interpretFValue(fValue) {
            if (fValue < 1) return 'No significant difference between groups';
            if (fValue < 3) return 'Small difference between groups';
            if (fValue < 5) return 'Moderate difference between groups';
            return 'Large difference between groups';
        }

        function displayResults(results, analysisMethod) {
            // Clear previous results
            analysisResults.innerHTML = '';
            analysisResults.style.display = 'grid';
            
            if (results.length === 0) {
                const noResultsDiv = document.createElement('div');
                noResultsDiv.className = 'result-card';
                noResultsDiv.innerHTML = '<p>No valid results found. Please check your data and variable selection.</p>';
                analysisResults.appendChild(noResultsDiv);
                return;
            }
            
            // Sort results by absolute value (descending)
            results.sort((a, b) => Math.abs(parseFloat(b.value)) - Math.abs(parseFloat(a.value)));
            
            // Display top results
            const maxResults = Math.min(4, results.length);
            
            for (let i = 0; i < maxResults; i++) {
                const result = results[i];
                
                const resultCard = document.createElement('div');
                resultCard.className = 'result-card';
                
                let resultHTML = `
                    <h3 class="result-title">${result.title}</h3>
                    <div class="result-value">${result.value}</div>
                    <p class="result-description">${result.description}</p>
                `;
                
                if (result.equation) {
                    resultHTML += `<p><strong>Equation:</strong> ${result.equation}</p>`;
                }
                
                resultCard.innerHTML = resultHTML;
                analysisResults.appendChild(resultCard);
            }
        }

        function generateChart() {
            const chartTypeValue = chartType.value;
            const xVar = xAxisVariable.value;
            const yVar = yAxisVariable.value;
            
            if (!xVar || !yVar) {
                alert('Please select variables for both axes.');
                return;
            }
            
            // Clear previous chart
            if (chart) {
                chart.destroy();
            }
            
            // Get selected color scheme
            const colors = colorSchemes[colorScheme.value] || colorSchemes.default;
            
            // Prepare data based on chart type
            let config;
            
            switch (chartTypeValue) {
                case 'scatter':
                    config = createScatterPlot(xVar, yVar, colors);
                    break;
                case 'bar':
                    config = createBarChart(xVar, yVar, colors);
                    break;
                case 'heatmap':
                    config = createHeatmap(colors);
                    break;
                case 'line':
                    config = createLineChart(xVar, yVar, colors);
                    break;
                default:
                    config = createScatterPlot(xVar, yVar, colors);
            }
            
            // Add chart title
            config.options.plugins.title = {
                display: true,
                text: chartTitle.value || `${yVar} vs ${xVar}`,
                font: {
                    size: 18
                }
            };
            
            // Create chart
            const ctx = chartCanvas.getContext('2d');
            chart = new Chart(ctx, config);
            
            // Show chart controls
            chartControls.classList.add('active');
        }

        function createScatterPlot(xVar, yVar, colors) {
            // Filter valid data points
            const validData = parsedData.filter(row => 
                typeof row[xVar] === 'number' && 
                !isNaN(row[xVar]) && 
                typeof row[yVar] === 'number' && 
                !isNaN(row[yVar])
            );
            
            // Create dataset
            const data = validData.map(row => ({
                x: row[xVar],
                y: row[yVar]
            }));
            
            // Calculate regression line if requested
            let regressionLine = null;
            if (showRegression.checked) {
                regressionLine = calculateRegressionLine(validData, xVar, yVar);
            }
            
            // Create chart configuration
            const datasets = [{
                label: `${yVar} vs ${xVar}`,
                data: data,
                backgroundColor: colors[0],
                borderColor: colors[0],
                pointRadius: 5,
                pointHoverRadius: 7
            }];
            
            // Add regression line if available
            if (regressionLine) {
                datasets.push({
                    label: 'Regression Line',
                    data: regressionLine.points,
                    type: 'line',
                    borderColor: colors[1],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false
                });
            }
            
            return {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: xVar
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: yVar
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${xVar}: ${context.parsed.x}, ${yVar}: ${context.parsed.y}`;
                                }
                            }
                        }
                    },
                    onClick: (e) => toggleChartControls(e)
                }
            };
        }

        function calculateRegressionLine(data, xVar, yVar) {
            // Prepare data for regression
            const points = data.map(row => [row[xVar], row[yVar]]);
            
            // Calculate regression
            const result = regression.linear(points);
            
            // Get min and max x values
            const xValues = data.map(row => row[xVar]);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            
            // Create points for the line
            const linePoints = [
                { x: minX, y: result.predict(minX)[1] },
                { x: maxX, y: result.predict(maxX)[1] }
            ];
            
            return {
                equation: result.string,
                r2: result.r2,
                points: linePoints
            };
        }

        function createBarChart(xVar, yVar, colors) {
            // Check if x variable is categorical or has few unique values
            const uniqueXValues = [...new Set(parsedData.map(row => row[xVar]))];
            
            let labels, data;
            
            if (uniqueXValues.length > 10 && typeof parsedData[0][xVar] === 'number') {
                // If x is numeric with many values, bin the data
                const bins = binData(xVar, 7);
                labels = Object.keys(bins);
                
                // Calculate average y value for each bin
                data = labels.map(bin => {
                    const binData = bins[bin].map(row => row[yVar]).filter(val => typeof val === 'number' && !isNaN(val));
                    return binData.length ? binData.reduce((a, b) => a + b, 0) / binData.length : 0;
                });
            } else {
                // Use unique x values directly
                labels = uniqueXValues;
                
                // Calculate average y value for each x value
                data = labels.map(label => {
                    const filteredData = parsedData
                        .filter(row => row[xVar] === label)
                        .map(row => row[yVar])
                        .filter(val => typeof val === 'number' && !isNaN(val));
                    
                    return filteredData.length ? filteredData.reduce((a, b) => a + b, 0) / filteredData.length : 0;
                });
            }
            
            return {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Average ${yVar} by ${xVar}`,
                        data: data,
                        backgroundColor: colors,
                        borderColor: colors.map(color => color),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: xVar
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `Average ${yVar}`
                            },
                            beginAtZero: true
                        }
                    },
                    onClick: (e) => toggleChartControls(e)
                }
            };
        }

        function binData(variable, numBins) {
            // Get numeric values
            const values = parsedData
                .map(row => row[variable])
                .filter(val => typeof val === 'number' && !isNaN(val));
            
            const min = Math.min(...values);
            const max = Math.max(...values);
            
            // Create bins
            const binSize = (max - min) / numBins;
            const bins = {};
            
            // Create bin labels
            for (let i = 0; i < numBins; i++) {
                const lowerBound = min + i * binSize;
                const upperBound = min + (i + 1) * binSize;
                bins[`${lowerBound.toFixed(1)}-${upperBound.toFixed(1)}`] = [];
            }
            
            // Assign data to bins
            for (const row of parsedData) {
                const value = row[variable];
                if (typeof value !== 'number' || isNaN(value)) continue;
                
                for (let i = 0; i < numBins; i++) {
                    const lowerBound = min + i * binSize;
                    const upperBound = min + (i + 1) * binSize;
                    
                    if (value >= lowerBound && (value < upperBound || i === numBins - 1)) {
                        const binKey = `${lowerBound.toFixed(1)}-${upperBound.toFixed(1)}`;
                        bins[binKey].push(row);
                        break;
                    }
                }
            }
            
            return bins;
        }

        function createHeatmap(colors) {
            // Get selected variables
            const selectedSleepVars = Array.from(sleepVariables.querySelectorAll('input:checked')).map(input => input.value);
            const selectedAcademicVars = Array.from(academicVariables.querySelectorAll('input:checked')).map(input => input.value);
            
            // Use all selected variables
            const variables = [...selectedSleepVars, ...selectedAcademicVars];
            
            if (variables.length < 2) {
                alert('Please select at least two variables for the correlation heatmap.');
                return createScatterPlot(xAxisVariable.value, yAxisVariable.value, colors);
            }
            
            // Calculate correlation matrix
            const correlationMatrix = [];
            for (const var1 of variables) {
                const row = [];
                for (const var2 of variables) {
                    if (var1 === var2) {
                        row.push(1); // Perfect correlation with itself
                    } else {
                        row.push(calculatePearsonCorrelation(var1, var2));
                    }
                }
                correlationMatrix.push(row);
            }
            
            // Create heatmap dataset
            const data = [];
            for (let i = 0; i < variables.length; i++) {
                for (let j = 0; j < variables.length; j++) {
                    data.push({
                        x: variables[j],
                        y: variables[i],
                        v: correlationMatrix[i][j]
                    });
                }
            }
            
            return {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Correlation Matrix',
                        data: data,
                        backgroundColor: function(context) {
                            const value = context.raw.v;
                            // Color scale from red (negative) to white (zero) to blue (positive)
                            if (value < 0) {
                                return `rgba(220, 53, 69, ${Math.abs(value)})`;
                            } else {
                                return `rgba(67, 97, 238, ${value})`;
                            }
                        },
                        borderColor: 'rgba(0, 0, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'category',
                            labels: variables,
                            title: {
                                display: true,
                                text: 'Variables'
                            }
                        },
                        y: {
                            type: 'category',
                            labels: variables,
                            title: {
                                display: true,
                                text: 'Variables'
                            },
                            reverse: true
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw.v.toFixed(2);
                                    return `Correlation: ${value}`;
                                },
                                title: function(context) {
                                    const item = context[0];
                                    return `${item.raw.y} vs ${item.raw.x}`;
                                }
                            }
                        },
                        legend: {
                            display: false
                        }
                    },
                    onClick: (e) => toggleChartControls(e)
                }
            };
        }

        function createLineChart(xVar, yVar, colors) {
            // Check if x variable is time-based or can be ordered
            const uniqueXValues = [...new Set(parsedData.map(row => row[xVar]))];
            
            // Try to sort values if they're numeric
            let sortedXValues = [...uniqueXValues];
            if (typeof parsedData[0][xVar] === 'number') {
                sortedXValues.sort((a, b) => a - b);
            }
            
            // Calculate average y value for each x value
            const data = sortedXValues.map(xValue => {
                const filteredData = parsedData
                    .filter(row => row[xVar] === xValue)
                    .map(row => row[yVar])
                    .filter(val => typeof val === 'number' && !isNaN(val));
                
                return {
                    x: xValue,
                    y: filteredData.length ? filteredData.reduce((a, b) => a + b, 0) / filteredData.length : 0
                };
            });
            
            return {
                type: 'line',
                data: {
                    datasets: [{
                        label: `${yVar} by ${xVar}`,
                        data: data,
                        backgroundColor: colors[0],
                        borderColor: colors[0],
                        tension: 0.3,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: typeof data[0]?.x === 'number' ? 'linear' : 'category',
                            title: {
                                display: true,
                                text: xVar
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: yVar
                            },
                            beginAtZero: true
                        }
                    },
                    onClick: (e) => toggleChartControls(e)
                }
            };
        }

        function toggleChartControls() {
            chartControls.classList.toggle('active');
        }

        function updateChart() {
            if (!chart) return;
            
            // Update chart title
            chart.options.plugins.title.text = chartTitle.value;
            
            // If axis variables changed, regenerate the chart
            if (chart.config.type === 'scatter' && chart.data.datasets[0].label !== `${yAxisVariable.value} vs ${xAxisVariable.value}`) {
                generateChart();
                return;
            }
            
            // Update colors based on selected scheme
            const colors = colorSchemes[colorScheme.value] || colorSchemes.default;
            
            // Update datasets colors
            chart.data.datasets.forEach((dataset, index) => {
                if (chart.config.type === 'bar') {
                    dataset.backgroundColor = colors;
                    dataset.borderColor = colors;
                } else {
                    dataset.backgroundColor = colors[index % colors.length];
                    dataset.borderColor = colors[index % colors.length];
                }
            });
            
            // Handle regression line for scatter plots
            if (chart.config.type === 'scatter') {
                // Remove existing regression line
                if (chart.data.datasets.length > 1) {
                    chart.data.datasets.pop();
                }
                
                // Add regression line if requested
                if (showRegression.checked) {
                    const xVar = xAxisVariable.value;
                    const yVar = yAxisVariable.value;
                    
                    const validData = parsedData.filter(row => 
                        typeof row[xVar] === 'number' && 
                        !isNaN(row[xVar]) && 
                        typeof row[yVar] === 'number' && 
                        !isNaN(row[yVar])
                    );
                    
                    const regressionLine = calculateRegressionLine(validData, xVar, yVar);
                    
                    chart.data.datasets.push({
                        label: 'Regression Line',
                        data: regressionLine.points,
                        type: 'line',
                        borderColor: colors[1],
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false
                    });
                }
            }
            
            chart.update();
        }

        function exportResults() {
            // Create a text representation of the results
            const selectedSleepVars = Array.from(sleepVariables.querySelectorAll('input:checked')).map(input => input.value);
            const selectedAcademicVars = Array.from(academicVariables.querySelectorAll('input:checked')).map(input => input.value);
            
            let resultsText = 'Sleep & Academic Performance Analysis Results\n';
            resultsText += '===========================================\n\n';
            resultsText += `Analysis Type: ${analysisType.options[analysisType.selectedIndex].text}\n`;
            resultsText += `Sleep Variables: ${selectedSleepVars.join(', ')}\n`;
            resultsText += `Academic Variables: ${selectedAcademicVars.join(', ')}\n\n`;
            
            // Add the results
            const resultCards = analysisResults.querySelectorAll('.result-card');
            resultCards.forEach(card => {
                const title = card.querySelector('.result-title').textContent;
                const value = card.querySelector('.result-value').textContent;
                const description = card.querySelector('.result-description').textContent;
                
                resultsText += `${title}\n`;
                resultsText += `Value: ${value}\n`;
                resultsText += `Description: ${description}\n`;
                
                const equation = card.querySelector('p strong');
                if (equation && equation.textContent === 'Equation:') {
                    resultsText += `${equation.parentNode.textContent}\n`;
                }
                
                resultsText += '\n';
            });
            
            // Create a blob and download link
            const blob = new Blob([resultsText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sleep_academic_analysis_results.txt';
            a.click();
            
            // Clean up
            URL.revokeObjectURL(url);
        }

        function exportChart() {
            if (!chart) return;
            
            // Convert chart to image
            const url = chart.toBase64Image();
            
            // Create download link
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sleep_academic_chart.png';
            a.click();
        }

        // Initialize the application
        init();

        // Sample data for demonstration (comment out in production)
        const sampleData = `student_id,sleep_duration,sleep_quality,bedtime,wake_time,class_attendance,study_hours,test_score,stress_level
1,7.5,8,23.5,7,90,25,85,4
2,6.2,6,1,7.2,75,20,72,7
3,8.1,9,22.5,6.6,95,30,92,3
4,5.5,4,2,7.5,60,15,65,8
5,7.8,7,23,6.8,85,22,80,5
6,6.5,5,0.5,7,80,18,75,6
7,7.2,8,23.2,6.4,88,28,83,4
8,5.8,5,1.5,7.3,70,16,68,7
9,8.5,9,22,6.5,98,32,95,2
10,6.0,6,0.8,6.8,78,21,74,6`;

        // Parse sample data
        const sampleBlob = new Blob([sampleData], { type: 'text/csv' });
        const reader = new FileReader();
        reader.onload = function(e) {
            parseCSV(e.target.result);
        };
        reader.readAsText(sampleBlob);
    </script>
</body>
</html>