<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REST vs GraphQL: Understanding the Differences</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #e94e77;
            --accent-color: #47b39d;
            --light-bg: #f8f9fa;
            --dark-text: #333333;
            --light-text: #ffffff;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark-text);
            background-color: var(--light-bg);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        h1 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: var(--secondary-color);
            font-size: 1.2rem;
            font-weight: 400;
        }
        
        .card {
            background-color: #ffffff;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 25px;
            margin-bottom: 30px;
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            border-bottom: 2px solid var(--light-bg);
            padding-bottom: 10px;
        }
        
        h3 {
            color: var(--secondary-color);
            margin: 20px 0 10px;
        }
        
        p {
            margin-bottom: 15px;
        }
        
        .comparison-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
        }
        
        .comparison-item {
            flex: 1 1 300px;
            background-color: #ffffff;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            overflow: hidden;
        }
        
        .comparison-header {
            padding: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        .rest-header {
            background-color: var(--primary-color);
            color: var(--light-text);
        }
        
        .graphql-header {
            background-color: var(--secondary-color);
            color: var(--light-text);
        }
        
        .comparison-content {
            padding: 20px;
        }
        
        .comparison-content ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .comparison-content li {
            margin-bottom: 10px;
            padding-left: 25px;
            position: relative;
        }
        
        .comparison-content li:before {
            content: 'âœ“';
            position: absolute;
            left: 0;
            color: var(--accent-color);
        }
        
        .code-example {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            overflow: auto;
            font-family: 'Courier New', Courier, monospace;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 5px;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            transition: var(--transition);
        }
        
        .tab:hover {
            background-color: #f0f0f0;
        }
        
        .tab.active {
            border-color: #ddd;
            background-color: #ffffff;
            position: relative;
        }
        
        .tab.active:after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: #ffffff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: var(--primary-color);
            color: var(--light-text);
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .use-case {
            border-left: 4px solid var(--accent-color);
            padding-left: 15px;
            margin: 15px 0;
        }
        
        .icon {
            font-size: 1.5rem;
            margin-right: 10px;
            vertical-align: middle;
        }
        
        .pros-cons {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        .pros, .cons {
            flex: 1 1 300px;
            padding: 15px;
            border-radius: var(--border-radius);
        }
        
        .pros {
            background-color: rgba(71, 179, 157, 0.1);
            border-left: 4px solid var(--accent-color);
        }
        
        .cons {
            background-color: rgba(233, 78, 119, 0.1);
            border-left: 4px solid var(--secondary-color);
        }
        
        .pros h4, .cons h4 {
            margin-bottom: 10px;
        }
        
        .pros ul, .cons ul {
            padding-left: 20px;
        }
        
        .pros li, .cons li {
            margin-bottom: 5px;
        }
        
        .button {
            display: inline-block;
            background-color: var(--primary-color);
            color: var(--light-text);
            padding: 10px 15px;
            border-radius: var(--border-radius);
            text-decoration: none;
            transition: var(--transition);
            cursor: pointer;
            border: none;
            font-size: 1rem;
        }
        
        .button:hover {
            background-color: #3a5a84;
            transform: translateY(-2px);
        }
        
        .button.secondary {
            background-color: var(--secondary-color);
        }
        
        .button.secondary:hover {
            background-color: #d13d66;
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px 0;
            border-top: 1px solid #ddd;
            color: #666;
        }

        @media (max-width: 768px) {
            .comparison-container {
                flex-direction: column;
            }
            
            .comparison-item {
                flex: 1 1 100%;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                flex: 1 1 auto;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>REST vs GraphQL</h1>
            <p class="subtitle">Understanding the key differences between two popular API architectures</p>
        </header>
        
        <div class="card">
            <h2>Introduction</h2>
            <p>APIs (Application Programming Interfaces) are essential components of modern web and mobile applications, enabling different software systems to communicate with each other. Two of the most popular API architectural styles are REST (Representational State Transfer) and GraphQL. This guide explores the fundamental differences between these two approaches, helping you understand when to use each one.</p>
        </div>
        
        <div class="comparison-container">
            <div class="comparison-item">
                <div class="comparison-header rest-header">REST API</div>
                <div class="comparison-content">
                    <p>REST (Representational State Transfer) is an architectural style that uses standard HTTP methods for communication between client and server. It was introduced by Roy Fielding in 2000 and has been the dominant API paradigm for many years.</p>
                    <h3>Key Characteristics:</h3>
                    <ul>
                        <li>Resource-based with multiple endpoints</li>
                        <li>Uses standard HTTP methods (GET, POST, PUT, DELETE)</li>
                        <li>Stateless communication</li>
                        <li>Predictable URL structure</li>
                        <li>Returns fixed data structures</li>
                    </ul>
                </div>
            </div>
            
            <div class="comparison-item">
                <div class="comparison-header graphql-header">GraphQL API</div>
                <div class="comparison-content">
                    <p>GraphQL is a query language for APIs developed by Facebook in 2015. It provides a more flexible and efficient approach to API design, allowing clients to request exactly the data they need.</p>
                    <h3>Key Characteristics:</h3>
                    <ul>
                        <li>Single endpoint for all operations</li>
                        <li>Client specifies exact data requirements</li>
                        <li>Strongly typed schema</li>
                        <li>Hierarchical data retrieval</li>
                        <li>Introspective (self-documenting)</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Key Differences</h2>
            
            <h3>1. Endpoint Structure</h3>
            <div class="tabs">
                <div class="tab active" onclick="switchTab(event, 'rest-endpoint')">REST</div>
                <div class="tab" onclick="switchTab(event, 'graphql-endpoint')">GraphQL</div>
            </div>
            
            <div id="rest-endpoint" class="tab-content active">
                <p>REST APIs typically have multiple endpoints, each representing a resource or collection:</p>
                <div class="code-example">
                    GET /api/users           # Get all users<br>
                    GET /api/users/123       # Get user with ID 123<br>
                    GET /api/users/123/posts # Get posts by user 123
                </div>
            </div>
            
            <div id="graphql-endpoint" class="tab-content">
                <p>GraphQL APIs typically have a single endpoint that accepts all queries:</p>
                <div class="code-example">
                    POST /graphql<br><br>
                    # Query body:<br>
                    {<br>
                    &nbsp;&nbsp;user(id: "123") {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;id<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;name<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;posts {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;}<br>
                    }
                </div>
            </div>
            
            <h3>2. Data Fetching</h3>
            <div class="tabs">
                <div class="tab active" onclick="switchTab(event, 'rest-fetching')">REST</div>
                <div class="tab" onclick="switchTab(event, 'graphql-fetching')">GraphQL</div>
            </div>
            
            <div id="rest-fetching" class="tab-content active">
                <p>REST APIs often require multiple requests to gather related data:</p>
                <div class="code-example">
                    # First request to get user<br>
                    GET /api/users/123<br><br>
                    # Second request to get user's posts<br>
                    GET /api/users/123/posts<br><br>
                    # Third request to get post comments<br>
                    GET /api/posts/456/comments
                </div>
                <p>This can lead to the "N+1 problem" where multiple round trips to the server are needed.</p>
            </div>
            
            <div id="graphql-fetching" class="tab-content">
                <p>GraphQL allows fetching all required data in a single request:</p>
                <div class="code-example">
                    # Single request to get user, posts, and comments<br>
                    {<br>
                    &nbsp;&nbsp;user(id: "123") {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;id<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;name<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;posts {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comments {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;}<br>
                    }
                </div>
            </div>
            
            <h3>3. Over-fetching and Under-fetching</h3>
            <div class="tabs">
                <div class="tab active" onclick="switchTab(event, 'rest-fetching-issues')">REST</div>
                <div class="tab" onclick="switchTab(event, 'graphql-fetching-issues')">GraphQL</div>
            </div>
            
            <div id="rest-fetching-issues" class="tab-content active">
                <p>REST APIs often return fixed data structures, which can lead to:</p>
                <ul>
                    <li><strong>Over-fetching:</strong> Receiving more data than needed</li>
                    <li><strong>Under-fetching:</strong> Not receiving enough data, requiring additional requests</li>
                </ul>
                <div class="code-example">
                    # Request for user data<br>
                    GET /api/users/123<br><br>
                    # Response includes ALL user fields, even if only name is needed<br>
                    {<br>
                    &nbsp;&nbsp;"id": "123",<br>
                    &nbsp;&nbsp;"name": "John Doe",<br>
                    &nbsp;&nbsp;"email": "john@example.com",<br>
                    &nbsp;&nbsp;"phone": "555-1234",<br>
                    &nbsp;&nbsp;"address": "123 Main St",<br>
                    &nbsp;&nbsp;"createdAt": "2023-01-15T12:00:00Z",<br>
                    &nbsp;&nbsp;"updatedAt": "2023-06-20T14:30:00Z"<br>
                    }
                </div>
            </div>
            
            <div id="graphql-fetching-issues" class="tab-content">
                <p>GraphQL allows clients to specify exactly what data they need:</p>
                <div class="code-example">
                    # Request only the name field<br>
                    {<br>
                    &nbsp;&nbsp;user(id: "123") {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;name<br>
                    &nbsp;&nbsp;}<br>
                    }<br><br>
                    # Response contains only requested data<br>
                    {<br>
                    &nbsp;&nbsp;"data": {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;"user": {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name": "John Doe"<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;}<br>
                    }
                </div>
            </div>
            
            <h3>4. Versioning</h3>
            <div class="tabs">
                <div class="tab active" onclick="switchTab(event, 'rest-versioning')">REST</div>
                <div class="tab" onclick="switchTab(event, 'graphql-versioning')">GraphQL</div>
            </div>
            
            <div id="rest-versioning" class="tab-content active">
                <p>REST APIs typically use explicit versioning in the URL or headers:</p>
                <div class="code-example">
                    # URL versioning<br>
                    GET /api/v1/users<br>
                    GET /api/v2/users<br><br>
                    # Header versioning<br>
                    GET /api/users<br>
                    Accept: application/vnd.company.v1+json
                </div>
                <p>This can lead to maintaining multiple API versions simultaneously.</p>
            </div>
            
            <div id="graphql-versioning" class="tab-content">
                <p>GraphQL typically avoids explicit versioning by using deprecation and adding fields:</p>
                <div class="code-example">
                    type User {<br>
                    &nbsp;&nbsp;id: ID!<br>
                    &nbsp;&nbsp;name: String!<br>
                    &nbsp;&nbsp;email: String!<br>
                    &nbsp;&nbsp;phoneNumber: String! # New field<br>
                    &nbsp;&nbsp;phone: String @deprecated(reason: "Use phoneNumber instead") # Old field marked as deprecated<br>
                    }
                </div>
                <p>This allows for evolving the API without breaking existing clients.</p>
            </div>
            
            <h3>5. Caching</h3>
            <div class="tabs">
                <div class="tab active" onclick="switchTab(event, 'rest-caching')">REST</div>
                <div class="tab" onclick="switchTab(event, 'graphql-caching')">GraphQL</div>
            </div>
            
            <div id="rest-caching" class="tab-content active">
                <p>REST APIs can leverage HTTP's built-in caching mechanisms:</p>
                <div class="code-example">
                    # Server response with cache headers<br>
                    HTTP/1.1 200 OK<br>
                    Cache-Control: max-age=3600<br>
                    ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
                </div>
                <p>This makes caching straightforward with standard HTTP tools and proxies.</p>
            </div>
            
            <div id="graphql-caching" class="tab-content">
                <p>GraphQL requires more complex caching strategies:</p>
                <ul>
                    <li>HTTP caching is less effective since requests typically go to a single endpoint</li>
                    <li>Client-side caching often uses unique identifiers for objects</li>
                    <li>Solutions like Apollo Client implement normalized caching</li>
                </ul>
                <div class="code-example">
                    # Apollo Client cache example<br>
                    cache.writeQuery({<br>
                    &nbsp;&nbsp;query: GET_USER,<br>
                    &nbsp;&nbsp;variables: { id: "123" },<br>
                    &nbsp;&nbsp;data: {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;user: {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__typename: "User",<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: "123",<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: "John Doe"<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;}<br>
                    });
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Performance Comparison</h2>
            <table>
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>REST</th>
                        <th>GraphQL</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Network Requests</td>
                        <td>Multiple requests often needed</td>
                        <td>Single request for complex data</td>
                    </tr>
                    <tr>
                        <td>Payload Size</td>
                        <td>Fixed, often larger than needed</td>
                        <td>Precisely what's requested</td>
                    </tr>
                    <tr>
                        <td>Backend Load</td>
                        <td>Predictable, endpoint-specific</td>
                        <td>Variable, depends on query complexity</td>
                    </tr>
                    <tr>
                        <td>Caching</td>
                        <td>Simple HTTP caching</td>
                        <td>Requires specialized solutions</td>
                    </tr>
                    <tr>
                        <td>Mobile Performance</td>
                        <td>Can be inefficient for limited bandwidth</td>
                        <td>Better for limited bandwidth</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="card">
            <h2>When to Use Each</h2>
            
            <div class="use-case">
                <h3>Choose REST when:</h3>
                <ul>
                    <li>Building public APIs with simple, resource-oriented operations</li>
                    <li>Caching is a priority</li>
                    <li>You need to leverage the HTTP protocol fully</li>
                    <li>Your API has a limited number of well-defined endpoints</li>
                    <li>You're working with a team familiar with REST principles</li>
                </ul>
            </div>
            
            <div class="use-case">
                <h3>Choose GraphQL when:</h3>
                <ul>
                    <li>Building complex applications with varied data requirements</li>
                    <li>Working with deeply nested and relational data</li>
                    <li>Optimizing for mobile applications with limited bandwidth</li>
                    <li>Aggregating data from multiple sources</li>
                    <li>You need a strongly typed API contract</li>
                    <li>You want to evolve your API without versioning</li>
                </ul>
            </div>
            
            <h3>REST Pros and Cons</h3>
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros</h4>
                    <ul>
                        <li>Simple and widely understood</li>
                        <li>Leverages HTTP standards</li>
                        <li>Excellent caching support</li>
                        <li>Stateless architecture</li>
                        <li>Well-supported by tools and libraries</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons</h4>
                    <ul>
                        <li>Multiple round trips for complex data</li>
                        <li>Over-fetching and under-fetching issues</li>
                        <li>Endpoint proliferation as API grows</li>
                        <li>Versioning can become complex</li>
                        <li>Documentation often separate from implementation</li>
                    </ul>
                </div>
            </div>
            
            <h3>GraphQL Pros and Cons</h3>
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros</h4>
                    <ul>
                        <li>Precise data fetching</li>
                        <li>Single request for complex data needs</li>
                        <li>Strong typing and self-documenting</li>
                        <li>Evolve API without versioning</li>
                        <li>Excellent developer tools</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons</h4>
                    <ul>
                        <li>Steeper learning curve</li>
                        <li>More complex server implementation</li>
                        <li>Caching is more challenging</li>
                        <li>Potential for complex queries that tax the server</li>
                        <li>File uploads require special handling</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Real-world Examples</h2>
            
            <h3>Companies Using REST</h3>
            <ul>
                <li>Twitter API</li>
                <li>PayPal API</li>
                <li>Stripe API</li>
                <li>Google Maps API</li>
                <li>Most public APIs</li>
            </ul>
            
            <h3>Companies Using GraphQL</h3>
            <ul>
                <li>Facebook</li>
                <li>GitHub</li>
                <li>Shopify</li>
                <li>Airbnb</li>
                <li>Netflix</li>
            </ul>
        </div>
        
        <div class="card">
            <h2>Conclusion</h2>
            <p>The choice between REST and GraphQL isn't about which is "better" overall, but rather which is more suitable for your specific use case. Many organizations even use both: REST for simple, public-facing APIs and GraphQL for complex internal applications.</p>
            
            <p>Consider your project requirements, team expertise, and long-term maintenance needs when making your decision. Both REST and GraphQL are mature technologies with strong ecosystems and can be excellent choices when applied appropriately.</p>
        </div>
    </div>
    
    <script>
        function switchTab(event, tabId) {
            // Hide all tab contents
            const tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            // Deactivate all tabs
            const tabs = document.getElementsByClassName('tab');
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove('active');
            }
            
            // Show the selected tab content
            document.getElementById(tabId).classList.add('active');
            
            // Activate the clicked tab
            event.currentTarget.classList.add('active');
        }
    </script>
</body>
</html>